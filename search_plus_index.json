{"./":{"url":"./","title":"README","keywords":"","body":"1. xtPhpBook1.1. 2018年09月25日1.2. 2018年09月26日1.3. 2018年09月30日1.4. 2018年10月02日1.5. 2018年10月03日1.6. 2018年10月05日1.7. 2018年10月13日1.8. 2019年01月01日1. xtPhpBook 这个文档的灵光乍现于2016年的9月，拖更了许久，今天终于开始了，真的是可喜可贺。 未来的都会在这个md上记录更新。 1.1. 2018年09月25日 A 下班之前编写好了计算机基础部分的一些内容。 1.2. 2018年09月26日 A 更新好了计算机基础部分的内容。 A 新建了文件夹第一部分和1 简介。 1.3. 2018年09月30日 A 更新了 简介。 1.4. 2018年10月02日 A 更新了 开发前准备。 1.5. 2018年10月03日 A 更新了 发布你的代码``初识php``变量和数据类型。 1.6. 2018年10月05日 A 更新了表达式、运算符。 1.7. 2018年10月13日 A 更新了语句和控制结构。 1.8. 2019年01月01日 A 更新到了类与对象。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s0/c0.html":{"url":"s0/c0.html","title":"Chapter0 计算机基础","keywords":"","body":"1. 绪篇2. Chapter0 计算机基础2.1. 认识电脑2.2. 计算机 Or 电脑？2.3. 硬盘与内存2.4. 计算机的文件结构2.5. 扩展名（后缀名）2.6. 数据与程序2.7. 编程？与电脑交流？2.8. 浏览器与网页2.9. 客户端应用与web应用2.10. web编程中的前端与后端2.11. 后端/后台？前端/前台？1. 绪篇 2. Chapter0 计算机基础 感谢你翻开了我的文档，你一定已经做好了学习web编程的打算与决心，相信你经过学习之后，会成为一个好的developer。 成为一个developer之前，作为编写文档的笔者，更希望你先成为一个power user。在那之前，我们先进行了解一些计算机领域的基础知识。 在这个章节我会去介绍一些计算机上的基础内容，大概包括以下内容： 一些基础的术语； 计算机内的文件系统与扩展名； 什么是数据； 在基础之后，为了能让你熟悉web编程，还会有下面的补充内容： 什么是客户端编程和网页编程； 浏览器与网页之间的关系； 什么是前端和后端，在决定学习之前应该怎样选择方向； 那么，让我们开始吧。 2.1. 认识电脑 在开始技术学习之前，我们需要对手中的计算机有所了解。经常听说一些亲戚朋友“谈电脑色变”，也经常有朋友用一种阴阳怪气的语气称呼技术人员为“电脑大神”。其实我们手上的电脑完全没有想象中的那样神秘，它只是一些精密零件的组合体。我们可以将电脑理解为一个大型的计算器。聪明的先行者们将所有数学问题都转换成了最基础的二进制运算，但这并不代表学习计算机技术之前都必须要精通二进制或是八进制或是十六进制运算——当然你如果会这几种运算一定是更好的。计算机将任何全部需要处理的问题都转换成了最底层的二进制运算，然后交给负责计算的单元来处理这些海量的计算。我们所陌生的计算机，本质上就是通过无尽的运算来完成全部的任务的。 如果想要了解更多关于计算机组成以及硬件之间如何协作的原理，可以参考计算机相关专业《计算机组成原理》课程教材。 2.2. 计算机 Or 电脑？ 这两个词是一个意思，但计算器和计算机不一样。 在这篇文档中，这两个词会反复使用，读者认为计算机和电脑一样就好了。 2.3. 硬盘与内存 硬盘是存在于我们电脑中的一个硬件设备，负责大容量的数据保存工作。广义上来讲，U盘、磁盘、（移动）硬盘等负责存储数据的硬件设备都属于硬盘类，它们的任务都是存储。相比于内存，硬盘的读写速率低。相对地，如果没有经历一些破坏性的灾难，硬盘的数据可以永久保存。 而内存是相对于硬盘存在的另外一个硬件设备，它的任务是临时存储。内存的读写速度特别快，但具有易失性。程序结束或者是计算机重启，对应的内存空间都会被释放。 举个例子，当你打开记事本，输入了一些文字，再你点击保存之前，输入文字是存在于内存中的。如果此时不保存数据关掉它，数据就从内存中消失了。但如果你点击保存，你输入的文字便会存储到硬盘中。 2.4. 计算机的文件结构 通常计算机的文件都是树形结构，也就是文件夹 - 文件的结构。以Windows系统为例，全部文件都可以在“我的电脑”（Windows7之后的版本中改名为“计算机”或“这台电脑”）中访问到。“我的电脑”被称为“根目录”。打开“我的电脑”后，在顶部显示的是地址栏。地址栏显示了当前所在的位置，位置信息的格式体现了文件夹和文件组成了树形结构。 2.5. 扩展名（后缀名） 计算机中的数据和程序都是以文件的形式存储的，计算机会通过扩展名来区分不同的文件类型。 在Windows下如果想要显示扩展名，打开“我的电脑”后选择“查看”，选择“文件夹选项”，取消勾选“隐藏已知文件类型的扩展名”。点击确定后文件夹窗口会闪烁刷新，然后你就会发现所有的文件名后边都加上了像.xxx这样的字符，小数点后面的字符就是扩展名。 扩展名标志了文件的类型，解决了“计算机该使用哪个程序来执行它”的问题。例如双击1.txt这个文件系统会使用记事本读取它的数据并打开，如果修改了打开方式，下次双击该文件的时候系统就会使用新的打开方式来读取它的数据。特别地，应用程序文件的扩展名是.exe，它们不会被其他程序打开，而是作为可执行程序启动。 下面列举了一些常用文件类型的扩展名。 类型 扩展名 文本文档 .txt 图片 .jpg .jpeg .bmp .png .gif 声音 .mp3 .wav .m4a 视频 .mp4 .wmv .avi .rvmb .mkv 压缩文件 .rar .zip .7z .tar 链接 .lnk .url 网页 .html .xhtml .mhtml 2.6. 数据与程序 程序就是可以执行的应用程序。像电脑上的.exe文件，以及手机上的App，它们被打开后可以执行相应的一些功能，这些都被称为程序。与程序对应的就是数据。 举个例子，我们打开记事本程序，接下来使用记事本新建一个文档，叫1.txt。我们再向记事本中输入一些内容，最后点击保存。整个过程中，记事本是程序，它的任务是记录用户输入的内容，并且保存到文件中。1.txt这个文件就是数据，它存储了我们输入的内容。 在使用计算机的过程中，通常是将程序和数据分开存放，这样可以让文件存放更有规律，使用过程中寻找文件的时候也有迹可循。如果计算机上装有固态硬盘（SSD，Solid State Drives），建议将程序安装在SSD上，数据存放在机械硬盘上，这样可以保证程序能更流畅地运行。 固态硬盘是硬盘的一种。常见的磁盘内部使用磁碟利用磁性记录数据，而固态硬盘是通过存储芯片达到存储的目的。磁盘读取数据时，需要通过移动磁头到相应位置才可以获取数据，而固态硬盘通过集成的电路代替了物理旋转磁盘，所以固态硬盘在速度上有巨大的优势，目前已经非常普及。 2.7. 编程？与电脑交流？ 编程，字面意义上来讲就是按照自己的意图去编写程序，让电脑能读懂，从而按照自己的意愿去操控电脑，让电脑为我们完成我们想完成的任务。就像没法与不懂中国话的外国人交流一样，你没法向不懂人话的计算机解释你要做什么，这时候就需要一个“人与计算机交流的工具”，来帮助人与计算机交流。这种“人与计算机交流的工具”就是编程语言。 与平常意义上的语言一样，编程语言也有词法和语法。在编程的过程中，熟悉了语法之后，我们就可以按照计算机能理解的方式来描述问题，将复杂的问题交给计算机解决了。 2.8. 浏览器与网页 浏览器是可以打开网页的应用程序。网页是文件，从原理上讲，网页都是文本文件。之所以网页有各种各样格式的内容，是因为编写网页的编程语言规定了一系列格式的表示方式，从而编程人员可以使用文本来表示对应的格式和样式。 编写网页的语言，常规上普遍使用HTML+CSS+JavaScript。HTML负责页面中“有什么”，CSS负责页面中各个部分“如何显示”和“显示成什么样”，JavaScript则负责页面中各个元素“能做什么”。 2.9. 客户端应用与web应用 客户端是传统意义上的“软件”，我们打开电脑后所使用的应用程序，大都属于客户端的范畴，例如QQ。客户端程序编写过程繁琐，开发成本高，同时开发人员还需要考虑程序在多个平台运行的兼容性。例如网易云音乐的客户端开发了多达8个版本（Windows、Linux、Mac OS、Android、iPad、iPhone、Windows Phone、UWP）。 web应用即运行在浏览器上的程序，就是人们常说的“网页”。最初的web应用只是在客户端功能的基础上进行阉割，在网页上实现一些基础的功能（如早期的web QQ）。渐渐地HTML技术越来越成熟，功能越来越强大，有越来越多的开发者投入web开发中。web应用编写起来简单且快速，很多创业团队依靠一个好的创新点，迅速开发出对应的web应用，快速切入市场。 近几年使用web应用创业成功的案例比比皆是，这些成功的案例无一不是极大地利用了web应用的优点。web应用开发起来迅速，开发成本低。web编程语言学习起来容易，出成品的速度是客户端编程所不能比拟的。相比于优点，取而代之的缺点就是，web应用受制于它的简单，无法发挥客户端程序所能发挥的作用。所以即使是在这个web应用横行的年代，一些大型的应用程序还是以客户端的形式呈现在用户眼前（例如Photoshop、Office等）。 2.10. web编程中的前端与后端 通常来讲，任何平台的编程都会分为前后端，前端负责显示和交互，后端负责数据和运算。在web编程中，前端就是用户看得见摸得到的网页，而后端是接收前端的请求、获取数据、进行运算等。 举个例子，我们现在打开了QQ空间，浏览器会首先加载前端页面的内容和样式，页面加载完成后处理JavaScript的逻辑。其中会有JavaScript代码的功能是获取朋友们发的说说列表，前端会将这个请求发送到后端提供的接口。后端接收到消息后前往数据库获取数据，将取到的数据处理成前端所需要的格式（通常是XML或者JSON），通过一些方式返回给前端。前端拿到数据之后，通过JavaScript提供的功能将数据显示给用户。 上面一段大致描述了前后端交流工作的过程，通常开发人员称呼这种方式为“接口式编程”。接口式将前后端进行拆分，使得彼此不需要了解对方的工作内容，双方可以使注意力更多地放在自己相关的工作上。相对于接口式编程，另外一种是后端直接将数据渲染在页面上的方式，这种方式在后面的内容中会详细解释。 那么在学习web编程之前，首先需要选择一个自己的方向，前端和后端，是完全不一样的两种思维。每个人的思维方式不同，就像有的人喜欢理科而有的人喜欢文科，在学习web编程的时候，当然也需要选择一个切入点进行学习。 前端更多的是设计与排版。作为前端工程师，需要考虑但不限于以下几点： 页面怎样显示才美观，可以把重要的信息准确地暴露给用户； 功能路径怎样设计才能让用户以一个舒服的体验完成操作； 页面中的功能逻辑要怎样设计才能让用户耗费最低的性能且获得最好的体验； 与后端进行交互的时候，哪些信息是必要的，哪些信息是非必要的。 后端更多偏向的是逻辑与计算能力。作为后端工程师，需要考虑但不限于以下几点： 需要向前端索要哪些数据； 面临一个问题，要怎样才能让计算机更高效率地完成计算而避免不必要的计算； 取到的数据需要进行怎样的处理或计算； 怎样能最大化地节约服务器资源，让用户更快地获取到数据； 在初期的学习中，前端可以更快地看到结果。编写好网页，只需要按下保存再双击打开，就可以在浏览器中看到自己编写的结果，相对于这一点来看，后端相对枯燥一些。但是当一个接口因为数据量过大而无法满足用户需求时，后端工程师挺身而出让这个接口的速度提升到感知不到的水平，那种喜悦更是解决一个前端无法比拟的。 所以，前端与后端各自有各自的特性，选择适合自己的开始学习，作为自己web编程的切入点，才是正确的对策。 2.11. 后端/后台？前端/前台？ 在学习的过程中难免要与其他人交流，交流的方式不限于问同学或者是上网查询资料。在与他人交流的过程中，这样四个词语足以让新手摸不着头脑。在讲解过前端和后端的区别后，我们有必要区分一下这四个词语。 后端和前端是我们普遍意义上的编程术语，后端指后端数据逻辑层，前端指表现交互层。后台通常意义上是指某个软件平台的后台管理系统，或者是说某个人有后台如何如何。前台通常是指公司负责接待客户的前台小姐姐。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s0/cn.html":{"url":"s0/cn.html","title":"前言与后记","keywords":"","body":"1.1. 前言与后记1.2. 使用本文档的一些tips1.1. 前言与后记 1.2. 使用本文档的一些tips 本文档中提到的代码，都会单独在n 代码目录中保存。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s1/c1.html":{"url":"s1/c1.html","title":"Chapter1 简介","keywords":"","body":"1. 第一部分 PHP与web编程2. Chapter1 简介2.1. PHP简介2.2. PHP如何存在2.3. PHP能做什么2.4. 怎样决定自己是不是真的要学习PHP2.5. 学习PHP需要什么前置技能1. 第一部分 PHP与web编程 2. Chapter1 简介 2.1. PHP简介 PHP是(PHP Hypertext Preprocessor)的首字母缩略词，是一种被广泛使用的、在服务器上执行的、简单易学且免费开源的脚本语言。 PHP于1994年由Rasmus Lerdorf创建。刚刚开始是Rasmus Lerdorf为了要维护个人网页而制作的一个简单的用Perl语言编写的程序，这些工具程序用来显示Rasmus Lerdorf的个人履历，以及统计网页流量。而后在PHP3.0中使用C语言对PHP进行重写，扩充了PHP的功能，使得PHP3.0成为了PHP历史版本中第一个被广泛使用的版本。 PHP发展到今天，已经获得了世界范围上的广泛认可。能取得种种成就，与PHP独有的魅力具有不可分割的联系。PHP作为一个简洁、高效、强大的服务端脚本语言，具有以下特征。 免费开源 PHP可以免费下载使用，并且可以在PHP的官网下载到PHP的C语言源码。任何人都可以按照自己的需求来定制PHP的功能。 简单易学 PHP几乎已经成为初学者首选的服务端语言。 强大、深邃且流行 PHP强大到足以成为在网络上最大的博客系统的核心（WordPress），深邃到足以运行最大的社交网络（facebook）。 2.2. PHP如何存在 硬盘上任何一个后缀名是.php的文件都是一个PHP脚本。 PHP脚本运行在服务器上，因此，运行PHP脚本的服务器要安装PHP的运行环境。PHP脚本返回的内容以纯文本的形式输出在浏览器上。 PHP脚本作为服务端程序，但是它其中可以包含HTML、CSS、JavaScript代码。可以理解为，PHP程序执行完毕，需要输出在浏览器上的内容，会被当成是一个网页的文档处理。假设一个PHP脚本的功能是输出一个script标签，script标签中有可执行的js程序。访问这个网址对应的PHP脚本时，会先在服务端执行PHP脚本，PHP脚本向浏览器输出一个script标签，页面加载完毕后，浏览器会像处理普通前端页面一样去处理当前PHP脚本返回的结果。 如果前面两句话你读起来一头雾水，不要着急，本章节我们就会详细介绍如何搭建一个最简单的PHP服务器。在那之前，我们需要先了解一下其他事情。 2.3. PHP能做什么 PHP能够在浏览器获取到页面内容之前就决定页面的内容，这对浏览器来说完全是静态的。 PHP能操作服务器上的文件，但前提是PHP程序在服务器上具有读写文件的权限。 PHP可以接受前端发送的表单或者是ajax数据，经过处理后决定需要返回数据或是存储到数据库。 PHP可以对数据库中的数据进行增、删、改、查等操作。 PHP可以操作cookies。 2.4. 怎样决定自己是不是真的要学习PHP 首先要明确PHP的定位，它是一门后端（服务端）语言，它运行在服务器上。其次，还需要知道，学习过程中，它更偏向于逻辑和运算，而不是表现，也就是说，可能在学习的过程中，你无法像前端那样很快就做出光彩夺目的页面，也不会很快就收获到第一笔成就感。因此，PHP更适合沉稳的性格的学习者。学习PHP需要你有一种能坐得住的定力，愿意为一个问题坐上一个下午，这样你会在美丽的落日余晖中收获PHP带来的快乐。 2.5. 学习PHP需要什么前置技能 你需要了解一些前端的基本原理，至少需要知道浏览器是怎样将一篇纯文本的代码解析成一个网页的。如果对自己要求更高一些，前端的全家桶（HTML、CSS、JavaScript）都能了解一下那一定是更好了。 如果你对前端编程还不太了解，或者甚至是一窍不通，那也不要紧。在下一节我们将对前端的内容进行简单的介绍，来满足学习PHP需要的前置技能要求。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s1/c2.html":{"url":"s1/c2.html","title":"Chapter2 HTML基础","keywords":"","body":"1. Chapter2 HTML基础1.1. 何为HTML1.2. 一个最简单的HTML网页1.3. HTML标签1.4. HTML相关的其他内容1. Chapter2 HTML基础 本节属于前端部分的一些基础内容。前面的内容提到，学习PHP需要有一些简单的前端基础知识作为前置技能。本节就简单介绍一些HTML的基础内容，作为学习PHP的准备。 1.1. 何为HTML HTML为超文本标记语言(HyperText Markup Language)的简写，是标准通用标记语言下的一个应用，通常用来编写网页。 HTML简单易用，只需要使用简单的标签就能编写出丰富的网页。同时HTML最大的亮点是它具有平台无关性，在任何位置编辑好的HTML文档，就能在任何平台上被任何浏览器读取。 1.2. 一个最简单的HTML网页 我们只需要在硬盘上新建一个.html文件，就已经创建好了一个标准的HTML文档。接下来我们向文件中写入内容。 这里是标题 这是我的第一个HTML文档。 第一个喔！ 这篇代码运行结果是 从上面这篇代码中，我们需要了解： 一个HTML文档由若干HTML标签组成，每个标签在页面加载的时候被浏览器解析成对应的形式，显示在页面上。 一个HTMl文档的全部内容被包含在一对html标签中。 每个标签都有自己对应的意义。 1.3. HTML标签 一个HTML标签通常是一对尖括号中包含一个英文单词的形式，例如。HTMl标签通常成对出现，组成一个元素。先出现的叫开始标签,后出现的叫结束标签。结束标签通常来说会比开始标签多一个斜线/。 例如一个一级标题元素这样使用HTML标签来表示： 这里是一级标题 也有的元素只由一个标签组成，因为这些元素从存在意义上来说，并不需要一对标签就能准确地表达它该有的意义。例如图片标签： 下面是一些常用的HTML标签： 标签 作用 html 整个html文档都被包含在一对html标签中 head 包含了页面中的一些头部信息 body 页面中主要显示的内容都在body中 style 写CSS代码的位置，记录了html文档中每个元素的样式 script 写JavaScript代码的位置，脚本代码写在这里 head标签下常用的标签有如下几种： 标签 作用 meta 规定了文档的一些头部信息，例如字符集、自适应规则等。这个可能读者还不容易理解。不用太纠结于此，如果目前不太了解，就先跳过也无所谓。 title 规定了网页的标题，这个标题会显示在浏览器的标题栏 body标签是整个网页的主体部分，该标签中包含了网页主要需要去显示的内容。常用的标签列举如下： 标签 作用 p 段落标签。该标签下的内容会被单独显示为一行。 h1~h5 一级标题~五级标题。一级标题最大，五级最小。会单独显示为一行 img 图片标签。需要注意的是，img标签是单标签形式，它只有一个结束标签。例如 a 超链接标签。会显示为超链接的形式，点击超链接可以跳转到文档的某一个位置或另一个url。例如打开百度 br 换行符。有br标签的位置会另起一行。该标签是单标签。例如或 div 分区(division)标签。这个标签的中文译名众说纷纭，然而这对我们来说并不重要。div标签起到分隔内容的作用，在前端编写页面的时候最为常用。 html标签远远不止这些，如果对这方面有很强的兴趣，建议你系统地学习一下前端部分的相关内容。 1.4. HTML相关的其他内容 之前已经提到过，除了HTML决定一个页面有什么内容，还有CSS来决定页面的元素如何显示，以及JavaScript来决定元素们都能做什么。这些内容都属于前端开发的范畴内，我们在此不详细介绍，但是作为要学习web开发的读者——你——应该要知道还有这些内容： 层叠样式表 CSS 脚本 JavaScript 需要准备的前置技能就这么多，下一节我们将介绍如何搭建开发环境。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s1/c3.html":{"url":"s1/c3.html","title":"Chapter3 开发前准备","keywords":"","body":"1. Chapter3 开发前准备1.1. 何为PHP运行环境1.2. 安装运行环境1.2.1. 在macOS下搭建PHP运行环境1.2.2. 在Windows在搭建PHP运行环境1.2.3. 测试运行环境是否搭建成功1.3. 开发前准备1. Chapter3 开发前准备 在第一节的PHP简介中我们提到，PHP脚本运行在服务器上，因此，运行PHP脚本的服务器需要安装PHP的运行环境。何为PHP运行环境？如何安装运行环境？这些都将在本节一一介绍。 1.1. 何为PHP运行环境 PHP是脚本语言，那么写好的PHP程序就是脚本，也就是一篇纯文本的脚本代码。要运行PHP程序，就需要电脑中有对应的解释器来执行这个程序。PHP程序就是这样的一个“翻译官”。 安装PHP后，服务器就可以通过PHP的主程序来运行脚本。如果算上PHP还需要连接数据库，这样一来PHP一家人就凑齐了。当我们从浏览器对一个PHP脚本发起一次访问，经历的过程是这样的：服务器通过服务器程序接收到请求，服务器寻找对应的脚本文件，PHP主程序解释脚本并运行，遇到数据库相关的代码则使用PHP提供的扩展去连接并操作数据库。 这一整个过程共包含了服务器上的四个组成部分： 服务器操作系统 服务器程序 PHP主程序 数据库 接下来我们将介绍在不同的平台下分别如何安装PHP运行环境。 1.2. 安装运行环境 在安装运行环境之前，需要解释一些事情。首先应该知道，搭建环境这项任务，在不同操作系统下流程是不一样的。这个“操作系统”区分的是Windows、Linux和macOS。本文档会从Windows和macOS两个系统来讲解如何搭建开发和运行环境。 本部分内容一切从简，所以我们会尽可能“偷懒”，也就是会选择最简单的方式来安装。要知道，学习PHP最重要的是快点着手于开发，而不是在准备工作上耽误太多时间。在日后的开发中也应明白这个道理。经常有爱折腾的开发者喜欢炫耀自己有多么地会折腾开发环境，实际上这是本末倒置的。 1.2.1. 在macOS下搭建PHP运行环境 在网上搜索安装MAMP或MAMP PRO，快速安装并运行。MAMP是macOS、Apache、MySQL、PHP的缩写，MAMP是一个macOS下的集成开发环境。 安装后的界面应该是这个样子的： 点击Start Servers来启动服务器。按下Command + ,查看一下服务器端口 图中看到我的端口号是3001。然后打开服务器，输入localhost:3001（3001改成你自己的端口），回车访问，如果出现MAMP的欢迎页面，则表示成功。 再按Command + ,打开设置页面，进入Web Server选项卡，将Document Rootx设置到一个自己建立好的目录下，用来存放代码，同时也将这个选择的目录作为本地网站的根目录。 图中我的设置，将磁盘Code设置为了根目录。这时候在我本地，目录/Volumes/Code/就被映射为了域名localhost:3001。 目录和域名之间的映射关系已经建立好，这个关系很重要，在后面的每一步开发中，你都需要知道当前文件的目录是什么，这样一来你才能在编写好程序后对其进行调试。 1.2.2. 在Windows在搭建PHP运行环境 Wamp是Windows、Apache、MySQL、PHP的缩写，Wamp是Windows下的集成开发环境。 在Wamp的官网下载一个Wamp Server的安装包，并根据自己的系统选择32位或64位。下载好之后安装。在中途会提示你选择两个目录，取消也好，选择也好。根据英文提示，分别选择默认的编辑器和浏览器。 Wamp下的磁盘和域名的映射关系是，{Wamp安装目录}/www/目录被映射到了localhost下。由于Apache默认占用80端口，所以不需要指定端口，直接访问域名即可。 在后续的介绍中，将不再纠结于服务器上的文件和域名之间对应关系的问题，在后续的学习和开发中如果对此还有疑问，请反复阅读本节相关内容，或者前往互联网查阅更多内容。 1.2.3. 测试运行环境是否搭建成功 前往网站根目录，新建一个脚本phpinfo.php，写入如下内容： //phpinfo.php 在浏览器中访问这个文件，会看到如下页面。 如果成功出现这个页面，则代表你的PHP开发环境已经搭建成功。 1.3. 开发前准备 开发环境已经就绪，则代表你的电脑已经做好了准备，就等你——伟大的造物者——来开始一场创造了。子曰，工欲善其事，必先利其器。即将开始写代码的我们，一定纠结于一个问题：用什么软件来写代码？在这里我将给出一些建议，但这不代表我的建议就是最好的。记住，没有最好的编辑器，只有最顺手的编辑器。 软件 介绍 Sublime Text 轻量级代码编辑器，有强大的插件支持，几乎能满足全部的需求。是国外的收费软件。 Visual Code 微软提供的轻量级代码编辑器，插件库在逐步扩大中。免费使用。 PhpStorm JetBrains公司提供的强大的PHP IDE，功能齐全，但体积较大。适合开发中大型项目。 Notepad ++ 系统记事本的扩展版，深受部分开发者喜爱。 Vim Linux和macOS系统下自带的编辑器，强大的快捷键功能使得其深受部分开发者喜爱。 建议初学者使用Sublime Text或Visual Code入门，待编程技术入门后，再根据自己的喜好继续深度使用或者是改用其他编辑器。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s1/c4.html":{"url":"s1/c4.html","title":"Chapter4 发布你的代码","keywords":"","body":"1. Chapter4 发布你的代码1.1. 服务器1.2. 域名1.3. 托管/上传代码1.4. 让世界都能访问到你的网站1.5. Hello World1. Chapter4 发布你的代码 1.1. 服务器 人们常说的服务器，实际上就是一个可以让任何人都能访问到的电脑，通常这个电脑只有一个主机，没有其他外设，通常使用其他工具进行远程操作。 “云”的概念被提出后，大厂们各自推出了自己家的云服务，“云服务器”的概念应运而生。云服务器的本质是一台大的服务器被虚拟成了很多台独立互不干扰的服务器，以按需计费的方式卖给用户，供学习或商业等用途使用。 购买了服务器之后我们就可以使用工具远程连接到服务器上，进行配置环境等操作。通常一台服务器会对应一个唯一的外网ip。配置好了服务器环境之后，就可以在外网任意一台设备上通过访问ip地址来访问到服务器上的文件。通常我们访问一个网页，本质上是通过某种导航访问到了对应服务器的ip上。 1.2. 域名 在人们常规的意识中，似乎域名才代表了“网站”，因为我们在访问一个网站的时候，只需要在浏览器的地址栏中输入一个域名就可以访问到对应的网站了。 在提供域名的服务商处购买了域名之后，可以对域名进行配置解析，解析可以将域名指向一个ip地址，配置完成后，就可以通过访问域名来访问到对应的服务器上了。 域名解析是一个很复杂的过程，这里只是做了最简单的描述。现在你只需要了解，是通过域名访问了对应的ip地址，从而访问到了对应的服务器资源即可。 1.3. 托管/上传代码 有了服务器，服务器也能运行程序，同时也能支持外网访问了，我们需要配置一个舒服的代码管理工具。代码管理工具可以让你以一个最简单的“上传 - 下载”的方式来管理代码，这样你可以更专注于编写功能，而不是折腾各种复杂的环境及配置。 常用的代码管理工具有SVN和GIT，两种工具各有千秋。SVN比较简单，只是简单的上传和下载功能，还提供代码版本管理的功能。如果两个人因为同时向服务器更改同一部分的代码而遇到了冲突，SVN也提供了解决冲突的方案。总体来看，SVN推荐给初学者使用。GIT工具是目前最盛行的代码管理工具，具有分支管理和版本控制等高级功能。除了最简单的上传、下载、同步等功能，GTI最大的亮点是其独有的分支机制。分支支持多个人同时编辑同一个文档，并检查各分支之间的差异，使代码能合并到最理想的状态。GIT功能强大，但不太容易驾驭，推荐给具有一定经验的读者使用。 还有一种方式不得不提，那就是FTP。准确来说，FTP不属于“代码管理方式”，而是一种传输文件的方式。对服务器配置好了FTP之后，我们可以在外网对服务器上的文件进行直接管理。FTP的方式相比于另外两种更为简单，但是不具有代码差异对照等功能，不适合多人协作。如果只是单人开发项目，则首选FTP方式，但如果涉及到多人协作和代码版本管理等相关功能，则推荐你在GIT和SVN中选择一个工具。 1.4. 让世界都能访问到你的网站 将代码上传到服务器了之后，一切都准备完毕。如果配置好了域名，则可以尝试通过域名访问服务器内的程序，或者通过IP访问服务器。如果提示访问失败，可能需要配置服务器程序（Apache），让它允许外网访问即可。 1.5. Hello World 国际惯例，学任何一门编程语言的第一课都是向世界问好。这样做确实是有必要的，因为可以通过这种方式，来快速地看到学习该语言的第一个可见的成果。 相信经过这么久的准备，你已经选择好了编辑器。那我们接下来使用心仪的编辑器，在服务器目录下新建一个文档（放在哪里都可以，只要是在服务器目录下），起名为\bhello.php，添加如下内容 // hello.php 打开浏览器访问该文件，看到如下页面 世界已经收到了我们的问候，我们也终于可以开始正式学习PHP这门伟大的编程语言了。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c5.html":{"url":"s2/c5.html","title":"Chapter5 初识PHP","keywords":"","body":"1. 第二部分 PHP基础语法2. Chapter5 初识PHP2.1. 让浏览器认识PHP2.2. 向浏览器输出内容2.3. HTML和PHP混合使用2.4. 注释1. 第二部分 PHP基础语法 2. Chapter5 初识PHP 2.1. 让浏览器认识PHP 浏览器对HTML的处理是以标签为单位，同时服务器对PHP进行处理也是从PHP标签开始的，一篇PHP程序被一对PHP标签包含。下面是一对标准的PHP标签： 通常在开发中，如果不涉及HTML文档内置PHP程序，通常会省略结束标签。这样PHP标签就变成了 只有夹在PHP标签中的代码才能被服务器作为PHP程序解析。 2.2. 向浏览器输出内容 PHP提供了一系列的输出函数可以用来向浏览器输出内容。如果还不了解什么是函数，不用着急，先学会使用即可。下面几段语句都可以输出对应的内容。 //print.php '; print('这是第二句话'); printf('这是第%d句',3); var_dump('我说完了'); 运行这篇代码，在浏览器中看到 上面四行代码都是向浏览器输出内容的功能，在功能性上各有千秋。通常echo和var_dump用得较多。echo会直接输出后面跟的内容，var_dump会同时输出变量的类型和内容。 向浏览器输出内容是最基本的调试方式。通常程序出了问题，都是先猜测问题出在哪里，将可能出现问题的相关变量输出出来，对照调试。这种方式在后面的学习中会逐渐提现其作用的。 2.3. HTML和PHP混合使用 前面提到，PHP脚本作为服务端程序，但是它其中可以包含HTML、CSS、JavaScript代码。可以看这样一篇代码 //withHtml.php 这里是标题 这是一篇带有HTML的php代码 这里将会夹带一个的代码 这段代码的运行结果是 这里看到，这个代码的文件本身是php程序，但是我们在php文件中输入的却是html的代码，在html代码中夹了一句php的代码。在程序执行的时候，将会先处理php代码，将该输出的内容输出在html中，再将结果交由浏览器，渲染成对应的网页形式。 2.4. 注释 在代码中，并不是所有代码都有对应的作用。注释作为代码的一部分，除了在代码中可以被看到，在程序运行过程中没有任何作用。但并不能因此而否认了注释的作用，相反地，注释是程序的灵魂。写注释的程序员不一定是好的程序员，但是不写注释的人一定不会做得更好。 PHP中常见的有三种形式的注释，它们分别是 // 单行注释以双斜线开头，只对一整行有作用。 /* 块注释以/ *开头，以* /结尾，中间的代码都会无效。 甚至可以跨越多行。 */ # php还支持shell样式的注释，以井号开头，与行注释作用相同。 注释通常用来为代码的功能进行相关的解释说明，方便其他人能读懂代码，也方便自己后期修改代码。一篇好的代码，应该包含至少1/3的简洁工整的注释。通常企业会有一套内部的代码规范，其中会对注释的格式进行详细的要求。一篇代码中的注释如果工整美观，甚至会比一篇好的文档还具有魅力。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c6.html":{"url":"s2/c6.html","title":"Chapter6 变量和数据类型","keywords":"","body":"1. Chapter6 变量和数据类型1.1. 变量1.2. 数据类型1.3. 获取变量的数据类型1.4. 判断变量是否属于某一个变量类型1.5. “空”1.5.1. 空字符串1.5.2. null1.5.3. 判断是否为空1.5.4. 判断变量是否定义1.6. 强制类型转换1.7. 字符和字符串1.8. 转义字符1.9. 数组1.10. 字符串与数组互相转化1. Chapter6 变量和数据类型 1.1. 变量 程序就是使用计算机的运算能力对一系列的数值进行高效的计算，这些数值在程序中存放的位置，就是变量。PHP是弱类型语言，所以和其他语言相比，PHP对变量支持无需声明，可以直接使用。 一个PHP变量使用美元符号$来标识，美元符号后跟上变量名即为一个变量。例如下面一行代码定义了一个变量a，它的值是100。 $a = 100; 一行代码也是一条语句，在PHP中，一条语句以分号;结束。 变量的名字是开发过程中开发者自己定义的，定义变量时，要遵守变量的命名规则。 变量的名字只允许数字、字母、下划线。 变量名不能以数字作为开头。 自定义的变量名不能与PHP的保留关键字重名。 变量都会有默认值，如果变量没有进行赋值而直接使用，就会引用到变量的默认值。默认值依变量类型而定。具体我们在变量类型中进行详细介绍。 1.2. 数据类型 变量也有类型，程序会根据变量的类型来存放不同种类的变量。整数存在整型变量中，小数存在浮点型变量中，字符串存在字符串类型的变量中……等等。由于PHP是弱类型语言，所以对变量类型的要求不会像C、Java等语言那样要求十分严格。在变量类型方面，我们开发时尽管使用就好。如果没有遇到变量类型引发的问题，我们在开发过程中是不需要特别关注变量类型的。 下表列举了PHP中常见的数据类型。 PHP关键字 变量类型 默认值 举例 int、integer 整型 0 $a = 3; float、double 浮点型 0 $a = 3.3; bool、boolean 布尔型 false $a = true; string 字符串类型 '' $a = 'This is a string'; 或 $a = \"This is a string\"; array 数组类型 [] $a = array('key' => 'value'); null 空类型 null $a;var_dump($a); 此外，还有object（对象）类型，在这里不作列举，等到接触过PHP的面向对象特性之后，你就会了解object类型了。 1.3. 获取变量的数据类型 PHP的内置函数gettype可以获取到变量的类型，返回字符串形式的变量类型的英文单词。 同时也可以使用var_dump来输出变量，也可以获取到变量的类型。 'value']; $f; echo 'a的变量类型是：'.gettype($a).''; echo 'b的变量类型是：'.gettype($b).''; echo 'c的变量类型是：'.gettype($c).''; echo 'd的变量类型是：'.gettype($d).''; echo 'e的变量类型是：'.gettype($e).''; echo 'f的变量类型是：'.gettype($f).''; var_dump($a); var_dump($b); var_dump($c); var_dump($d); var_dump($e); var_dump($f); 这篇代码的运行结果是 可以看到，gettype函数只能获取到变量类型的字符串，而var_dump则可以输出变量类型和变量的值。两个方法适用场景不同，在未来的开发中都有可能会用到。 1.4. 判断变量是否属于某一个变量类型 PHP内置了一系列的判断类型的函数，它们统一的命名规则是is_type()。它们的参数都是一个变量，返回值都是bool类型，如果该变量是对应的类型则返回true，否则返回false。这一组函数列举如下。 函数名 别名 作用 is_int is_integer、is_long 是否为整型 is_float is_double 是否为浮点型 is_string 是否为字符串 is_bool 是否为布尔型 is_null 是否是NULL is_array 是否为数组 is_object 是否为对象 is_numeric 是否为数字或数字字符串 1.5. “空” 在PHP中，有几种与“空”相关的变量，需要特别注意。 1.5.1. 空字符串 如下这种方式创建的字符串就是空字符串，在获取前端传来的数据时很常见。 $a = ''; 或者是 $b = \"\"; 1.5.2. null null是PHP中一种特殊的类型，叫做“空类型”。通常只有这两种方式来创建一个空类型的变量： $a; $a = null; 1.5.3. 判断是否为空 可以使用is_null这个函数来判断变量的值是否为空。如果对应数组的话，可以使用empty函数来判断数组是否为空。如果是字符串，则可以使用$a == ''这种方式来判断字符串是否为空。 1.5.4. 判断变量是否定义 变量为空与变量未定义是两种完全不同的状态，而且这两种状态容易混淆。变量为空，意味着变量已经定义，但是没有赋值，或者因为某种原因，导致变量没有了值；变量未定义，是指在当前程序中根本没有存在过要使用的变量。 变量是否已经定义，可以使用isset函数来判断。 1.6. 强制类型转换 由于PHP是弱类型语言，变量会由系统根据变量值自动指派一个变量类型，这种机制虽然方便，但对有些场景来说是有缺陷的。当我们需要自己指派一个变量的类型的时候，就用到了强制类型转换。 强制类型转换的方式是，在变量左边加上(type)形式的变量类型关键字。例如 $a = '123'; $b = (int)$a; 会将本来是字符串的变量$a强制转换为整型。 强制类型转换在某些情况下可能会使变量值的精度受损，或者是丢失值。例如 $a = 123.45; (int)$a; // $a => 123 会使a的值变成123，直接丢失掉小数点后面的值。 这种情况 $a = 'abc'; (bool)$a; // $a => true 会使a的值变成true。 当遇到一些奇怪的使用场景时，强制类型转换就会变得不那么可控，例如 $a = null; (string)$a; // $a => '' 所以，强制类型转换的功能应妥善使用，根据需求使用即可。切勿将毫无关联的两种类型互相转换，类似的操作会使程序增加更多的不可控因素。 1.7. 字符和字符串 在PHP中，对“字符”和“字符串”的区分并不是很强，可以理解为“字符”的概念包含在“字符串”的概念中。“字符”即单个的一个字母、数字、英文符号。下面几行代码的作用都是定义了一个变量并存入一个字符。 $a = 'a'; $b = '1'; $c = ','; 多个字符在一起则组成字符串，例如下面几行代码都定义了一个字符串。 $a = 'china'; $b = 'php is the best server side language'; $c = \"asdfghjkl\"; 声明字符串的形式有两种,一种是用单引号夹住字符串的内容，另一种是则用双引号。二者的区别在于，双引号会解析其中的变量值，单引号会将其中的内容全部当成字符串。例如下面一段代码对此有所体现。 在开发过程中，使用单引号声明的字符串性能会更好，因为PHP无需解析字符串是否包含需要处理的变量。 //string.php $price = 12; echo \"青菜的价格是{$price}元\"; echo '青菜的价格是$price元'; 这段代码的运行结果是 为了在单引号情况下也能插入变量值，我们通常会使用字符串连接的方式。连接两个字符串要使用运算符.，就是英文的小数点符号。.可以将两边的字符串连接起来组成新的字符串。例如上面的例子可以改写成下面这一行代码。 //string.php $price = 12; echo '青菜的价格是'.$price.'元'; 运行的结果与上例第二行的结果是相同的。 1.8. 转义字符 在编程中，我们有时候会试图向程序描述一些键盘上所没有的内容，例如“换行”。通常我们在键盘上按下回车键即可输入一个换行，但程序是以行为单位的，在代码中输入一个回车键，代码就被分成两行了。类似这种情况，有一类字符被特别地称为“转义字符”，被用来描述“键盘上所没有的内容”。一些常用的转义字符列举如下。 转义字符 转义之后表达的内容 举例 \\n 换行，接下来的内容会另开一行 \\t 制表符，接下来的内容会向前移动一个tab的距离 \\' 一个单引号 ' \\\" 一个双引号 \" \\/ 一个斜线 / \\\\ 一个反斜线 \\ \\$ 一个美元符号 $ 需要注意的是，转义字符只能在双引号声明的字符串中使用，在单引号中使用转义字符，会按原样输出。下面几行代码展现了转义字符的作用。 //string.php echo \"下一句话会在下一行出现\\n是吧\"; echo \"下一句话会在下个制表符出现\\t是吧\"; echo \"接下来由各种符号出现：\\'\\\"\\/\\\\\\$\"; echo '单引号中转义字符不能用：\\n\\t\\'\\\"\\/\\\\\\$'; echo \"\\n\"; 这段代码在浏览器中的运行结果是 看上图的运行结果，好像并没有体现转义字符的作用。这时候我们可以在HTML代码中试一下，在body标签中输入回车，会按照换行来显示吗？原来在HTML中，换行、制表符、多个空格，都会按照一个空格来处理。所以我们这里的\\n和\\t，都没法体现出作用。我们可以尝试在命令行中运行这个程序。 在命令行中运行的结果这这样的。 这样看来则体现了转义字符的作用。 1.9. 数组 数组也是PHP中所支持的一种强大的数据类型。将任意多个值或键值对放在一起即为数组。 PHP中使用array函数来声明一个数组，如果你的PHP版本不小于5.4，还可以使用一对方括号[]来更简洁地声明一个数组。例如下面两段代码声明了两个相同的数组。 $arr = array('username' => 'abc123','password' => 'pwd123'); $arr = ['username' => 'abc123','password' => 'pwd123']; 如果输出这个数组 //array.php var_dump($arr); 则可以看到运行结果 PHP中的数组非常强大，可以将任意一种结构的数据整理成需要的多维数组。PHP中支持索引数组和关联数组两种形式，对C语言的数组功能做了极大的扩充。C语言的数组、结构体；JavaScript中的对象等，都可以涵盖在PHP的数组中。 1.10. 字符串与数组互相转化 在编程中我们会有这样一种需求，我们会得到一种很有规律的字符串，并且希望将这个字符串的各个部分分别进行处理。这时候我们可以使用explode函数来将字符串分割成数组。explode的使用方式是 array explode ( string $delimiter , string $string [, int $limit ] ) 参数 说明 delimiter 使用哪个字符来分割整个字符串 string 要分割的字符串 limit 非必需。如果设置了 limit 参数并且是正数，则返回的数组包含最多 limit 个元素，而最后那个元素将包含 string 的剩余部分；如果 limit 参数是负数，则返回除了最后的 -limit 个元素外的所有元素；如果 limit 是 0，则会被当做 1。 explode函数的使用方式是 //array.php $str = 'apple,grape,banana,pear'; $fruits = explode(',',$str); var_dump($str); echo ''; var_dump($fruits); 这段代码的运行结果是 相对的，还有另外一个函数是implode，它可以将数组元素使用某一个字符串来连接起来形成一个字符串。例如上面的数组可以使用这种方式来还原： $fruit_str = implode($fruits); var_dump($fruit_str); 数组和字符串是PHP编程过程中两个最重要的变量类型，在后面的开发中也会有所体现。在这里只是简单提及，在后面还会有更详细的内容来详细介绍数组和字符串。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c7.html":{"url":"s2/c7.html","title":"Chapter7 表达式和运算符","keywords":"","body":"1. Chapter7 表达式和运算符1.1. 表达式1.2. 运算符1.2.1. 赋值运算符1.2.2. 算数运算符1.2.3. 逻辑运算符1.2.4. 字符串连接符1.2.5. 运算赋值运算符1.2.6. 位运算符1. Chapter7 表达式和运算符 PHP是一门服务端编程语言，PHP要完成的工作与“计算”息息相关。程序中的计算与数学中的计算并无本质上的差距。有计算则一定有两个因素，那就是运算数和运算符。数学中的运算数即程序中的变量，在上一节中已经进行了详细的介绍。那么接下来的内容就是“计算”中的另一大元素，运算符。 在进行详细介绍各种运算符之前，我们需要先了解一个程序中的概念——表达式。 1.1. 表达式 何为表达式？表达式的概念可以类比于数学中的“算式”。将需要参与计算的变量与运算符一起，结合成可以计算的形式即为表达式。表达式可长可短，无论表达式形式如何，都一定可以计算出一个唯一的值。和函数的概念相同，这个值可以被称作表达式的返回值。 1.2. 运算符 表达式可以类比为“算式”，那么PHP的运算符和数学中的运算符则相差无几。PHP中运算符的概念是在数学的四则运算的概念上进行了一定程度上的扩充，来完成更完备的计算工作。例如在前文中提到的 $a = 1; 一句代码中，=就是一个运算符，叫做“赋值运算符”。常见的运算符及其作用可以用下表来概括。 在列举之前需要提及一个概念，叫“元”。每个运算符都可以从“元”的角度来进行评价，我们称一个运算符是“几元运算符”。元的意义就是，这个运算符需要几个运算数来参加运算。例如加运算是二元，因为需要两个数相加。 1.2.1. 赋值运算符 运算符 名称 作用 举例 元 备注 = 赋值运算符 赋值 $a = $b + 1 2 将右边所得的数值赋值给左边的变量。 1.2.2. 算数运算符 算术运算符通常用来进行算数运算，两边的操作数都是具体的数值或表示数值的变量，返回值是计算结果。 运算符 名称 作用 举例 元 备注 + 加号运算符 “加”运算 $a + $b 2 - 减号运算符 “减”运算 $a - $b 2 * 乘号运算符 “乘”运算 $a * $b 2 / 除号运算符 两数相除 $a / $b 2 % 取模运算符 求余运算 $a % $b 2 两数相除，取余。整除得0。 ++ 自加运算符 自加运算 $a ++ 1 将运算数的值+1 -- 自减运算符 自减运算 $a -- 1 将运算数的值-1 自加和自减运算符可以用在运算数左边，也可以用在右边，两种方式有各自的不同。这个区别将在循环结构一节有所提及。 1.2.3. 逻辑运算符 逻辑运算符通常进行逻辑运算，通常是进行某一种判断。运算结果通常是true（真）和false（假）。 运算符 名称 作用 举例 元 备注 && “与”运算符 “与”运算 $a && $b 2 两边的值进行逻辑与运算，返回值是bool型，true或false。 \\ \\ “或”运算符 “或”运算 $a \\ \\ $b 2 两边的值进行逻辑或运算，返回值是bool型，true或false。 ! “非”运算符 “非”运算 !$a 1 对变量进行逻辑非运算，返回值是bool型，true或false。 > 大于 $a > $b 2 小于 $a 2 == 等于 $a = $b 2 判断两边变量是否数值相等 >= 大于等于 $a >= $b 2 小于等于 $a 2 !=、<> 不等与 $a != $b 2 === 完全相等 $a === true 2 判断两边变量的数值和类型是否完全相等 ?: 问号运算符 判断条件决定执行哪一句 ($a == 1)?$b = 4:$b = 2; 3 唯一的三元运算符。判断第一句的真假，真则执行第二句，假则执行第三句。 1.2.4. 字符串连接符 运算符 名称 作用 举例 元 备注 . 字符串连接符 连接两个字符串 $a.$b 2 将两边的字符串连接成一个新的字符串。 1.2.5. 运算赋值运算符 一些运算可以和赋值运算符同时使用，可以在计算的同时执行赋值操作。可以使代码更加精简、美观。 这类运算符类似这样： +=、-=、*=、/=、&=、\\|=、!=、.= 它们的作用是，先进行相关运算，将得到的结果赋值给左边的变量，例如： $a = 1; $b += $a; //$b == 2 1.2.6. 位运算符 将整数视为二进制进行运算。位运算在大部分场景下很少见，在一些特殊场合却非常好用。 例如RGB颜色由6个16进制数组成，例如#FF0000，前两位数表示红色亮度为255，绿色和蓝色均为0。假如我需要获取绿色的亮度，此时就需要用到位运算来实现了。将FF0000和00FF00做按位与，即可获取到绿色的亮度。按位与的特点是有两个比特，只要存在0则结果为0。如果两个比特都是1时，则结果为1。 位运算的实例F8的二进制为1111 1000C9的二进制为1100 1001F8和C9做按位与运算，按位与是两个比特全为1时，结果为1。F8和C9的高4位分别为1111和1100，按照按位与的定义，结果应该为1100，因为只有前两位对应位置的二进制数才都为1。同理计算第四位，F8和C9分别为1000和1001，结果应该为1000，因为两个数只有第一个位置的二进制数均为1，其他都不满足这个条件，所以结果为1000。将结果合并起来，结果为1100 1000。 运算符 名称 作用 举例 元 备注 & 按位与 将两个数字做按位与运算，有0则结果为0 0x4 & 0x6 2 \\ 按位或 将两个数字做按位或运算，有1则结果为1 0x4 \\ 0x6 2 ^ 按位异或 将两个数字做按位异或运算，一个为1一个为0时，结果为1，反之为0，即不同为1，相同为0 0x4 ^ 0x6 2 ~ 按位取反 将一个数字做按位取反，当为1时结果为0，当为0时结果为1 ~ 0x6 1 左移 将数字按位左移，空位补0（每一次移动都表示“乘以 2”） 0x6 2 >> 右移 将数字按位右移，空位补0（每一次移动都表示“除以 2”） 0x6 >> 1 2 位移在 PHP 中是数学运算。向任何方向移出去(超出范围)的位都被丢弃。左移时右侧以零填充，符号位被移走意味着正负号不被保留。右移时左侧以符号位填充，意味着正负号被保留。 运算符连接起了变量，而表达式则是运算符和变量结合的成果。之前的内容，我们可以理解为学习了“单词”和“短语”。接下来将接触到的就是“句子”和“段落”，最后写成整篇代码就是“文章”。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c8.html":{"url":"s2/c8.html","title":"Chapter8 语句和控制结构","keywords":"","body":"1. Chapter8 语句和控制结构1.1. 语句1.2. 语句块1.3. 选择结构1.3.1. if-else选择结构1.3.2. switch结构1.4. 循环结构1.4.1. while结构1.4.2. do-while结构1.4.3. for结构1.5. 改变循环状态1.5.1. continue语句1.5.2. break语句1.6. goto语句1. Chapter8 语句和控制结构 1.1. 语句 一般的编程语言通常都以语句为基本单位，程序由多条语句构成。PHP中，分号;标记了一个语句的结束，并且一条语句必须以分号作为结束。 任何具有意义的程序代码都可以作为一条语句。例如之前提到的表达式$c = $a + $b，倘若在后面加上一个分号，就成了一条语句。 $c = $a + $b; 正常情况下，PHP程序是从上到下按照语句的排列顺序来执行，如果想要完成更复杂的业务逻辑，则需要借助控制结构。和其他的编程语言相同，PHP也具有选择结构和循环结构。 控制结构可以改变语句的执行顺序，使得原本单调的顺序结构得以扩展，让程序可以解决更复杂的问题。 1.2. 语句块 语句块由多个语句组成，包含在花括号{}中。语句块通常表示一组功能上有关联的代码，通常在选择结构、循环结构、函数上使用。 1.3. 选择结构 选择结构会使程序流程增加分支，程序运行到分支处时，会根据选择条件的判断结果来决定执行哪一个分支。如果你在数学课上学习过程序框图的话，这张图你一定不会陌生 上图是一个最简单的if选择结构。通过多个if结构堆叠起来，可以实现更多分支的选择结构，例如： 但是在编写代码的过程中，这样写是非常冗余的，而且也不利于维护。如果想要表达一个平行的多分支选择结构，通常会是这个样子 上述三种结构，都是很常见的选择结构。下面我们将介绍如何使用代码来表达这三种结构。 1.3.1. if-else选择结构 if结构实现的是单条件选择，通常的形式是这样的： if($cond){ //do something }else{ //or do another thing } $cond可以是一个值，也可以是一个变量，更常见的是一个逻辑表达式。当$cond的值为true时，执行if下面花括号中的语句块，否则执行else中的语句。例如下面一段代码。 0){ echo 'a大于0'; }else{ echo 'a不大于0'; } $_GET是PHP自带的超全局变量，可以用来获取get方式传过来的变量值。这部分内容会在后面进行详细讲解。这里可以理解为是获取一个值，这个值来自你访问的url。 运行这段代码。首先访问/code/choose.php?a=2，得到的结果是 修改访问的url，访问/code/choose.php?a=-1，得到的结果是 在这段程序中，首先我们从get参数中获取到了$a的值，并根据$a的值的不同情况，分别给出不同的处理。 当业务逻辑复杂起来，需要我们处理更多种情况的时候，可以叠加使用if-else结构。我们接下来看一个具体的问题。 某小学成绩和成绩等级对应如下表： |等级|成绩| |:--:|:--:| |A|100~80| |B|79~60| |C|59~40| |D|39~20| |E|19~0| 现需要编写程序，输入成绩等级，程序会给出对应的成绩区间。 如果使用if-else结构，我们这样编写代码： 尝试运行代码 我们看到，当分支情况复杂起来的时候，if结构也会变得异常复杂。上面的例子只是简单的叠加情况，代码就冗余成这种程度。通常当我们需要处理一系列平级的选择条件时，通常会使用switch结构。 1.3.2. switch结构 switch结构是选择结构的另一种方式，通常用来处理具有多个平行条件的选择结构。switch结构通常的形式是这样的： switch($value){ case $value1 : do_something_1();break; case $value2 : do_something_2();break; case $value3 : do_something_3();break; ... default : do_default_thing(); } 程序会将value与下面每一个case后面的value比较，执行值互相匹配的case后面的语句。break会使程序在执行完对应的功能之后退出switch结构。关于break的作用会在循环结构中详细讲解。 case匹配之后执行的语句可以是一条，也可以是一个语句块。case后面的结构也可以是这个样子： switch($value){ case $value1 : { do_something_1_1(); do_something_1_2(); }break; ... } 如果没有任何一个case与value相匹配，则执行default后面的语句。如果没有default情况，则直接跳出switch结构。 如果使用switch结构处理刚才“成绩-等级”的问题，可以改写成如下代码： //scoreAndRank.php switch($rank){ case 'A' : echo '该同学的成绩区间是：100~80';break; case 'B' : echo '该同学的成绩区间是：79~60';break; case 'C' : echo '该同学的成绩区间是：59~40';break; case 'D' : echo '该同学的成绩区间是：39~20';break; case 'E' : echo '该同学的成绩区间是：19~0';break; default : echo '输入的成绩等级不合法'; } default情况不是必须的，但是通常具有一定经验的程序员，都会在switch结构中补齐default情况。这样可以使程序结构和逻辑更加完整，而且可以避免出现一些不可预料的情况。 switch结构也有一定的缺陷和局限性。switch结构只能处理“等于”的情况。思考一下，如果将上述问题改为“输入成绩，输出成绩等级”，这时switch结构就没有办法应付这个问题。 if和switch两种结构各有各的优势和劣势，在实际编程中应灵活变通。选择最适合的语句结构，程序才会有最优的效率。 1.4. 循环结构 除了选择结构外，另一种结构就是循环结构。通常我们会用循环结构来处理“需要反复处理”的问题。循环结构会让程序在运行过程中的某几步之间往复进行，当满足某一些条件的时候再跳出循环结构。用框图表示一个最普通的循环结构如下图所示： 我们来看一个具体的问题。 使用程序求1~100自然数的和。 这个问题在数学中再简单不过了,使用数学上的求和符号，一步就算出了结果。 使用程序解决这个问题，实际上和求和符号的原理相同，都是用了“循环”的思想。PHP有三种方式来描述选择结构，接下来我们将借助这个简单的求和问题来一一认识它们。 1.4.1. while结构 while结构的一般形式是： while($cond){ //do something } 当$cond成立，就一直执行花括号内的语句块。使用while解决上面的求和问题，代码可以这样写： 这里的$sum += $a;$a ++;可以写成$sum += $a++; 在程序中，当系统读到a++时，会先读取a的值来进行相关运算，之后再将a的值增加1。相反地，如果使用++a，则会先将a的值增加1，再读取加1后的值来进行相关运算。--a和a--同理。 1.4.2. do-while结构 do-while结构的一般形式是： do{ //do something }while($cond) do-while会先执行语句块，再判断$cond是否成立，如果成立则重复语句块的内容。与while结构相比，do-while会先执行后判断。在这二者中，需要根据具体的情形来选择需要使用哪一个结构。二者都是循环结构，在本质上并无太大区别，只是有时候使用do-while会比使用while更容易思考问题。 1.4.3. for结构 for结构的一般形式是： for(语句1; 语句2; 语句3);{ //do something } for结构的运行流程是这样的。 for结构是最常用的循环结构。上面的求和问题如果改写成for结构的话，代码可以改写成： for结构的强大之处在于，上面所说的三条语句，可以理解为“程序的三个时刻”，并不一定要局限于三条语句。第一个位置通常被称为“初始状态”，第二个位置被称为“循环条件”，第三个位置则是每次循环过后需要处理的内容。 如上面的代码所示，初始状态中我们为$i和$sum赋了初始值，这里用逗号连接了两条语句。而第三个位置中的$i++，实际上也可以写在语句块之内。 1.5. 改变循环状态 为了体现编程不是那么简单的，我们不能用一个求和的问题来来回回算了好多遍。那现在我们来考虑另外几个循环的问题。 问题8.1:计算自然数1~1000中，全部偶数的和。 问题8.2:自然数中，从1开始计算总和，直到遇到500以后的第一个3的倍数。 基于上述两个问题，我们来介绍continue和break语句。 1.5.1. continue语句 在循环体内使用continue语句时，会跳过本次循环，直接开始下一次循环。用流程图表示的话是这个样子的： 考虑上面的问题8.1。如果要计算全部偶数的和，那我们就循环1~1000，遇到奇数跳过（continue）就可以了。下面我们编写代码。 为了让continue的效果更直观，我们在else中加一句 echo $i.'被跳过了。'; 运行这段代码，我们看到结果是 在运行结果中看到，所有的奇数都被跳过，所有的偶数都被加入了总和中。在continue语句的帮助下，这个问题就解决了。 1.5.2. break语句 与continue相比，break就显得很绝情。在循环体内使用break语句时，会使当前循环直接结束。break语句在流程图中是这样的： 考虑问题8.2。从1开始循环自然数，先不用决定在哪里停下，因为在解决问题之前谁也不知道500后面的第一个3的倍数是什么。当判断当前的数字大于500并且是3的倍数，就停止循环。在这之前，所有的数字都要加入加和之中。问题构思好了，我们来编写代码。 500 && $i % 3 == 0){ break; } $i ++; } echo '遇到500之后的第3的倍数时自然数的总和是：'.$sum.'，这个3的倍数是：'.$i; 这段代码的运行结果是 可以看到，在判断条件成立时，break语句使while循环结构直接中断，使程序流程跳转到了循环之外。 1.6. goto语句 与选择结构、循环结构相比而言，至少前两者都还是有规律可循的。选择结构会按照判断的条件来使程序进入不同的分支，循环结构则会按照判断条件使程序进行某种往复的工作。但goto语句与二者都不同。作为可以控制程序流程的一条语句，它没有任何规律。goto语句会使程序直接跳转到某一个特定的位置。 goto语句通常与标号同时使用。标号和goto语句通常形式是这样的： //标号 flag: //跳转 goto flag; 我们看这样一段代码。 '; echo '我也不知道接下来会发生什么。'; echo 'goto来啦！'; if($f){ echo '回到开始！'; $f = false; goto flag; }else{ echo '程序结束！如果不设置分支，程序会死循环。'; } 这段代码的运行结果是 这段代码体现了goto语句标号和跳转的使用方法。 经验丰富的前辈们往往指出，goto语句具有很大的不可控因素，在编程中不推荐使用。但要这样考虑，goto语句作为编程语言中的一部分，一定有它存在的意义。编程过程中一定要按照自己的意愿去做，也就是“把真实的你讲给计算机听”。goto是一把利刃，是一把锋利的双刃剑。善用它，往往会事半功倍。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c9.html":{"url":"s2/c9.html","title":"Chapter9 函数与程序模块化","keywords":"","body":"1. Chapter9 函数与程序模块化1.1. 什么是函数1.2. 函数的声明和调用1.3. 参数和返回值1.4. 函数库与程序模块化1.4.1. 直接复制代码1.4.2. include1.4.3. require1. Chapter9 函数与程序模块化 1.1. 什么是函数 函数是一个具有固定功能的程序模块，每个函数具有它自己的名字和相应的功能。例如我们在一开始就使用的echo，它的功能是向浏览器输出一个字符串。 从函数的创建者来划分，函数分为系统定义的函数和开发者创建的函数。从功能上来划分，又可以分为数学函数、数组处理函数、字符串处理函数等等。函数可以实现的功能是不可限量的，任何一种功能或者是任何一段程序，都可以被装进一个函数中。我们将这种“装入”的过程叫做封装。 下面我们就从创建一个函数开始，来介绍函数这个强大的功能。 1.2. 函数的声明和调用 函数和变量一样，也要有自己的名字。函数的起名规则与变量相同，通常一个函数的名字表示了这个函数实现的功能。声明一个函数的一般形式如下所示： function fun($arg1,$arg2,...){ //do something return $returnValue; } 函数使用function关键字声明，后面是函数名字。括号中是函数的参数，参数不是必须的。紧接着下面是函数体，函数体由多条语句、控制结构等程序组成。return指示了程序的返回值。一个函数不一定要有返回值，但程序一定要执行了一定的功能，否则这个函数没有任何意义。 例如下面一段代码，定义了一个函数，这个函数完成了四则运算的功能。 //fun1.php function calc($a,$b,$c){ switch($b){ case '+' : return $a + $c; case '-' : return $a - $c; case '*' : return $a * $c; case '/' : return $a / $c; default : return '不支持+-*/之外的运算'; } } 再编写一段程序，来调用这个函数。 //fun1.php $a = $_GET['a']; $b = $_GET['b']; $c = $_GET['c']; if($a && $b && $c){ echo '开始运算了！'; echo '运算结果是：'; echo calc($a,$b,$c); echo ''; }else{ echo '运算数或运算符不够！'; } 1.3. 参数和返回值 参数和返回值是函数的两大要素。一个函数存在的意义，即“谁参加了计算”和“函数做了什么事情”。参数，即参加计算的成员。参数在函数定义时，在函数名后边的括号中已经按顺序排列好，并且中间使用逗号隔开。调用函数的时候，需要根据函数定义时候的顺序依次传入参数，这个动作叫做“传参”。而对于返回值的解释应该是，类比数学中的函数，“返回值”对应的概念就应该是函数值，即函数执行完毕应该得到什么。在函数体中，使用return标识返回值。函数在运行到return语句中停止并将返回值传给上层调用函数的位置，函数流程也跟着跳转过去。所有在return后面的语句都不会被执行。 例如上面例子中的函数，函数名是calc，它的作用是将参数1和参数3进行参数2的运算，将计算的结果作为返回值返回。 关于函数、参数、返回值等概念，可以用如下流程图来解释。 1.4. 函数库与程序模块化 PHP为开发者提供了一系列的系统定义函数，这大大提升了PHP的功能性。但是同时这既是PHP的优点又是PHP的缺点，由于系统函数的数量过于庞大，导致开发者往往记不得全部的能用得到的函数。有的时候想要实现的功能是已经存在的系统函数，却因为不知情而去自己重写相同的功能。 开发的过程中离不开函数，函数使程序模块化，可以提升程序的复用性。但是进行功能封装时，应该避免将功能过度细分。一个函数保持具有其独立的功能即可。 作为无私且伟大的程序员，将自己的代码分享给别人是大家都具有的美德。分享代码时，通常分享的是“功能”。即将你解决了某种问题的步骤或者是算法封装在一个函数中，将函数写在一个php文件中，将这个php文件分享给别人。当别人拿到这个文件的时候，有很多种方式可以在自己的代码中使用这个文件。 1.4.1. 直接复制代码 拿到别人的代码后，直接打开文件，将需要的功能复制进自己的代码中，稍加改进即可直接使用。这种方式最简单，但是复用性不高。 试想，如果你现在需要解决A问题，然后在网上下载到了解决A问题的代码。这时候你打开代码，复制粘贴到了自己的代码中。当你写下一段代码的时候，又遇见了A问题，这时候如果还需要使用这段别人的代码，就还需要再复制一次。这种使用方式会让代码变得很冗余。 就算不是使用别人的代码，在自己编写代码的时候，也应该尽可能地将单独的功能封装起来，作为函数去调用。 1.4.2. include include()可以将另一个php文件包含进当前的php文件中，并且将目标文件的代码放在include的位置上。 如果要避免同一个文件被重复包含，可以使用include_once()函数。 1.4.3. require require()也可以实现将代码包含进来的功能，同样也可以使用require_once()来避免重复包含同一个文件的问题。但是require和include有所区别。 require会不加判断直接将代码复制粘贴过来，而include则会按照代码的执行顺序决定是否要包含。例如下面两段代码： if($a > 1){ include_once('phpinfo.php'); } if($b == 0){ require_oncce('pnpinfo.php'); } 第一段代码在if判断为真的情况下，才会将phpinfo.php中的代码包含进当前代码中，如果判断不为真，则不会执行任何包含的程序。 而第二段代码直接等价于下面这段代码： if($b == 0){ phpinfo(); } 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c10.html":{"url":"s2/c10.html","title":"Chapter10 数组","keywords":"","body":"1. Chapter10 数组1.1. 数组简介1.2. 定义一个数组1.3. 使用数组1.4. 数组 & 字符串1.5. 数组操作函数1.5.1. 堆栈 & 队列1.5.2. 键 & 值1.5.3. 遍历1.5.4. 数组排序1.5.5. 其他的数组相关常用函数1. Chapter10 数组 1.1. 数组简介 在C语言中，我们对数组的定义是“将一些相同变量类型的值放在一个集合里”。而在PHP中，你可以将任何类型的变量或数值放在一个数组中。PHP中，数组可以理解为是一组任何形式的值的集合。 1.2. 定义一个数组 与数组相关的关键字是array，你可以用这样的方式来创建一个数组： $arr = array(); 在php5.4之后，数组的关键字新增了[]形式，也就是说，在php5.4之后，你可以用这样的方式来创建一个数组： $arr = []; 这种书写方式相比于之前便捷得多。 在之后的讲解中，都将使用array的形式。array形式的数组比较常见，而且不会有版本兼容问题。 PHP中的数组实际上是将任何形式的数据组织成了键=>值的形式，而且这种形式可以嵌套。例如下列代码分别展示了一位数组、二维数组以及多维数组的创建。 $arr1 = array(1 => 'a',23 => 'bc',45 => 'de',678 => 'fgh'); $arr2 = array( 1 => 'a', 2 => array( 22 => 'bb', 23 => 'bc' ) ); $arr3 = array( 'code' => 0, 'msg' => '成功', 'data' => array( 0 => array( 'name' => 'wyfan', 'engname' => 'kris' ), 1 => array( 'name' => 'hztao', 'engname' => 'ztao' ) ) ); 1.3. 使用数组 使用数组很简单，使用数组名+键名就可以访问了。普遍的形式是这样： //arr.php echo $arr3['data'][0]['name']; 基于上面的$arr3的值，上面一行代码会输出 如果想要输出数组的值，可以直接使用var_dump函数。例如直接输出上面的$arr3的值： //arr.php var_dump($arr3); 这样执行的结果是： 1.4. 数组 & 字符串 在实际开发中经常会遇到类似这样的需求： 你可以从一些来源（文件或网页等）获取到类似这样的数据： 小明,小红,小刚,小智,小霞,小茂,皮卡丘,大木博士 将这样的数据整理成数组，再进行接下来的操作。 针对类似这样的问题，PHP提供了好用的函数explode来解决问题。explode函数的定义是 explode(separator,string,limit); 参数名 意义 separator 必需，分隔符 string 必需，要分割的字符串 limit 要返回的元素数目。大于 0 - 返回包含最多 limit 个元素的数组；小于 0 - 返回包含除了最后的 -limit 个元素以外的所有元素的数组；0 - 返回包含一个元素的数组 例如上述问题可以用这种方式来解决： $str = '小明,小红,小刚,小智,小霞,小茂,皮卡丘,大木博士'; $arr = explode(',',$str); var_dump($arr); 程序的运行结果是： 如果接下来需要存入数据库，那么数组就更容易接受了。 相对于explode，PHP还提供了对应的反函数implode，这个函数可以将数组变成字符串。implode函数的定义是 implode(separator,array); 参数名 意义 separator 可选。规定数组元素之间放置的内容。默认是 \"\"（空字符串）。 array 必需。要组合为字符串的数组。 我们将上面的问题改一下。 已有条件都不变，我们最终需要将列表变成竖线|分割的形式。 当然这个问题可以使用字符串替换sre_replace来解决，但是我们现在需要体现implode的作用，所以我们需要连续使用explode和implode两个函数。上面的问题可以这样解决： $str = '小明,小红,小刚,小智,小霞,小茂,皮卡丘,大木博士'; $arr = explode(',',$str); $newStr = implode('|',$arr); var_dump($newStr); 程序运行结果是 1.5. 数组操作函数 1.5.1. 堆栈 & 队列 堆栈和队列可以理解为是进出规则不同的两种容器。堆栈是后进先出（LIFO），用图表示则是这样的： 队列则是先进先出（FIFO）： 在PHP中，这两种结构都可以用数组来表示。对数组元素进行添加和删除，涉及到了如下函数。 array_push(arr,value1,value2,...) 将一个值追加在数组末端，返回新数组元素的个数。 参数 解释 arr 必需，要进行操作的数组 value1 必需，要追加进数组的值 value n 其他要追加进数组的值 此函数还有一种简略的形式 $arr[] = $value; 这种方式也会将值添加在数组末端，也就是说array_push相当于多次调用上述形式。如果只需要将一个值加入数组，不如用上述形式便捷，同时也没有调用了函数的负担。 即使数组是键值对形式，新加入的元素的键依然是数字。 我们可以用这样一个程序来测试array_push。 //arraypush.php $arr = array( 'first' => 'apple', 'second' => 'banana' ); $newValue = 'orange'; var_dump($arr); $res = array_push($arr,$newValue); var_dump($arr,$res); $arr[] = 'cherry'; var_dump($arr); 运行程序，我们可以看到程序的运行结果。 array_push返回了新数组的元素个数，新加入的元素的键是数字。并且两种添加元素的方法产生了相同的作用。 在实际应用中，数组最外层大多是数字键，这种数组往往表示一个列表。所以在array_push的应用场景下，你不必担心新元素的键是数字的问题。 array_pop(arr) 删除数组arr的最后一个元素，如果操作成功则返回最后一个元素值，如果arr非数组或数组是空的，则返回NULL。如果arr不是数组，系统还会给出警告。 参数 解释 arr 必需，要操作的数组 对此只需要一段简短的代码就可以测试这个函数的作用了。 //array_pop.php $arr = array( 'first' => 'apple', 'second' => 'banana' ); $lastValue = array_pop($arr); $fakeArr = 'fake'; $emptyArr = array(); $test1 = array_pop($fakeArr); $test2 = array_pop($emptyArr); var_dump($lastValue,$arr,$test1,$test2); 程序运行结果是 array_shift(arr) 删除并返回arr的第一个元素。如果数组本身是以数字为键，则新数组会获得新的键，从0开始并递增。 参数 解释 arr 必需，要操作的数组 为此我们要编写一段程序来测试结果。 //array_shift.php $arr = array('apple','banana','cherry'); var_dump($arr); $firstValue = array_shift($arr); var_dump($firstValue,$arr); 程序的运行结果是 array_unshift(arr,value1,value2,value3...) 向数组arr头部插入元素，返回新数组的元素个数。数组键将从0开始递增，新元素的顺序与参数顺序保持一致。 参数 解释 arr 必需，要进行操作的数组 value1 必需，要插入进数组的值 value n 其他要插入进数组的值 接下来的例程将要测试此函数的功能。 //arrayunshift.php $arr = array('apple','banana','cherry'); var_dump($arr); $res = array_unshift($arr,'pig','monkey'); var_dump($arr,$res); 程序的运行结果是 1.5.2. 键 & 值 使用array_values函数可以得到数组值组成的新的数组，使用array_keys函数可以得到数组键组成的新的数组。 //keysAndValues.php $arr = array( 'code' => 0, 'msg' => 'success', 'data' => array( array( 'classname' => 'chinese', 'classtime' => '8:00', 'classroom' => '501' ), 'what are you nongshalei?' ) ); $keys = array_keys($arr); $values = array_values($arr); var_dump($keys,$values); 上述代码运行结果是 1.5.3. 遍历 PHP中使用foreach结构可以遍历数组的所有元素，并对数组元素进行相应处理。foreach结构的一般形式是 foreach($arr as $key => $value){ //do something } 在循环体中，$key表示当前循环的键，$value表示当前循环的值。$key和$value都是临时变量，每次循环都会使其变化，并在循环体执行完毕后不复存在。 当不需要关注数组键的时候，foreach还有简略形式： foreach($arr as $value){ //do something } 下面我们使用foreach结构，将一个“待办事项”数组向用户输出为一个代办清单。 //foreach.php $arr = array('week up','wash face','go out','work','back home','sleep'); echo \"you will do following things tomorrow:\\n\"; foreach($arr as $k => $v){ echo $k.':'.$v.\"\\n\"; } echo \"finish!\\n\"; 1.5.4. 数组排序 函数名 作用 sort 使数组按照升序排序 rsort 使数组按照降序排序 ksort 根据键的升序排序 asort 根据值的升序排序 krsort 根据键的降序排序 arsort 根据值的降序排序 1.5.5. 其他的数组相关常用函数 量取长度 count 去重 array_unique 合并 array_merge 拆分 array_slice 随机取值 array_rand 随机洗牌 shuffle 数组的相关操作函数还有很多，在此不一一列举。你可以根据实际开发需要查询相关函数。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c11.html":{"url":"s2/c11.html","title":"Chapter11 字符串","keywords":"","body":"1. Chapter11 字符串1.1. 字符串简介1.2. 字符串操作函数1.2.1. html相关操作1.2.2. 查找、截取、替换1.3. 字符串 & 数组1.4. 模式1.4.1. 元字符1.4.2. 转义字符1.4.3. 模式修饰符1.4.4. 正则表达式相关函数1. Chapter11 字符串 1.1. 字符串简介 在变量和数据类型一章中，我们已经对字符和字符串进行了简略的介绍。我们提到，字符串是用单引号''或双引号\"\"包含的一串字符，并且双引号中间可以插入变量，但单引号不可以。使用英文的符号.来连接两个字符串。 1.2. 字符串操作函数 函数名 功能 strlen 返回字符串长度 strtolower 将所有字符转为小写 strtoupper 将所有字符转为大写 1.2.1. html相关操作 函数名 功能 htmlspecialchars 将html预定义的字符转换为HTML实体 strip_tags 去掉字符串中的html标签 1.2.2. 查找、截取、替换 substr(str,start,length) substr函数将字符串str从start位置开始截取，共截取length长度，返回截取后的字符串。length参数可选，如缺少length参数，则截取到字符串末端。 //stringFunc.php $str = 'Welcome to China'; $subStr1 = substr($str,7,2); $subStr2 = substr($str,7); var_dump($str,$subStr1,$subStr2); strpos(str,find,start) strpos函数会在字符串str中搜索find，并返回第一次出现的位置。start参数可选，可指定从何处开始搜索。默认从str的开头开始搜索。 //stringFunc.php $str = 'Welcome to China'; $strPos = strpos($str,'China'); var_dump($str,$strPos); str_replace(find,replace,str,count) str_replace函数会在str字符串中搜索find子串，并将所有子串替换成replace字符串，并返回替换后的字符串。替换的数量将记录在count中。count参数可选。 //strreplace.php $str = 'I will destroy.'; $count = 0; $newStr = str_replace('destroy','fade',$str,$count); var_dump($str,$newStr,$count); 这个函数还有更多的用法。例如如果想将字符串中的元音字母都替换成其他符号，第一个参数find此时允许是数组。当find是数组，则会再str中搜索所有数组中出现的元素，替换成replace。 //strreplace.php $str = 'I will destroy.'; $count = 0; $newStr = str_replace('destroy','fade',$str,$count); var_dump($str,$newStr,$count); 如果find和replace都是数组的时候，则会按照两边数组的元素一一对应来替换。此时replace数组元素数量应该小于等于find数组元素的数量（理想情况应该是等于）。 //strreplace.php $str = 'I will destroy.'; $count = 0; $newStr = str_replace(array('i','e','o'),array('~','|','+'),$str,$count); var_dump($str,$newStr,$count); 如果两个数组数量不匹配，则会出现一些异常情况。如果replace数组元素少，find数组中没有对应到的元素则会替换成空字符。 1.3. 字符串 & 数组 在数组一章中我们提到了explode和implode函数，在这里不重复叙述。 1.4. 模式 模式这个词经常与另一个概念正则表达式同时出现。一个模式串可以表示一系列具有同样特征的字符串，模式串可以理解为是一系列字符串的概括。 正则表达式不是单纯属于PHP的技术，正则表达式是一种独立的理念，它不属于任何技术，但是可以被其他很多技术使用。就像你在编程中会用到数学，但数学不属于任何编程语言，它是自然存在并且独立的。 /[0-9]/可以表示“任意一个数字”，/[A-Za-z]/则表示“任意一个字母”。正则表达式的一般格式是 /表达式/[修正符] 正则表达式由若干个原子组成，每个原子允许是以下内容： 单个字符、数字，如a-z，A-Z，0-9。 模式单元，如(ABC)可以理解为由多个原子组成的大的原子。 原子表，如[ABC]为A或B或C的其中之一。 重新使用的模式单元，如：\\\\1。 普通转义字符，如：\\d、\\D、\\w。 转义元字符，如\\*、\\.。 具有特殊意义的字符（被称为元字符）。 1.4.1. 元字符 [aoeiu]表示任意一个单独的元音字母。[0-9]表示任意一位数字。[a-z][0-9]表示一个小写字母和一个数字组成的两位字符。[a-zA-Z0-9]表示任意一个大小写字母或数字。 [^]表示除了该元字符表示的字符之外的任何字符，相当于对[]取反。例如[^0-9]表示任意一位非数字字符。 {m}表示对前面元字符的数量控制。例如[0-9]{4}表示任意四位数字。[1][35789][0-9]{9}表示手机号码。 {m,n}也可以表示对前面元字符的数量控制，并提供了一个数量区间。例如[a-z]{4,8}表示4到8位的小写字母。 对元字符的数量控制上，还有几种简写方式。*表示任意次，等价于{0,}；+表示至少一次，等价于{1,}；?表示0次或1次，等价于{0,1}。例如正整数可以表示为[1-9][0-9]*，整数可以表示为[\\-]?[0-9]+。 ()表示一个整体的原子，例如(ABC)表示ABC这个字符串的整体，(red|blue)表示red或者blue，(abc){2}表示两个abc。 ^用在正则表达式的开头，表示必须以此字符开头。$用在正则表达式的结尾，表示必须以此字符结尾。.表示除换行符之外的任意字符。 1.4.2. 转义字符 转义字符 含义 \\d 匹配一个数字，等价于[0-9] \\D 匹配除数字以外任何一个字符，等价于[^0-9] \\w 匹配一个英文字母、数字或下划线，等价于[0-9a-zA-Z_] \\W 匹配除英文字母、数字和下划线以外任何一个字符，等价于[^0-9a-zA-Z_] \\s 匹配一个空白字符，等价于[\\f\\n\\r\\t\\v] \\S 匹配除空白字符以外任何一个字符，等价于[^\\f\\n\\r\\t\\v] \\f 匹配一个换页符，等价于\\x0c或\\cL \\n 匹配一个换行符，等价于\\x0a或\\cJ \\r 匹配一个回车符，等价于\\x0d或\\cM \\t 匹配一个制表符，等价于\\x09\\或\\cl \\v 匹配一个垂直制表符，等价于\\x0b或\\ck \\oNN 匹配一个八进制数字 \\xNN 匹配一个十六进制数字 \\cC 匹配一个控制字符 1.4.3. 模式修饰符 模式修饰符放在正则表达式右边斜线的外侧，来修饰本次匹配。 i表示不区分大小写，即/[a-zA-Z]/等价于/[a-z]/i。 s表示匹配视为单行。 U会让匹配成功即停止，拒绝贪婪匹配。 1.4.4. 正则表达式相关函数 preg_match_all(pattern,subject,matches) preg_match(pattern,subject,matches) preg_match_all会进行全文匹配，返回匹配的个数。preg_match只会匹配一次，成功返回1，否则返回0。 两个函数都会在subject中根据pattern模式进行匹配，将匹配到的结果放在matches中。其中matches参数可选，如果没有matches参数则只返回匹配个数，用于检查模式串是否匹配。 正则表达式的应用场景远比上面的描述要广泛得多，甚至可以将正则表达式当成一门独立的语言来进行学习。这里只进行简单的叙述。 下面我们编写一个简单的程序来体现正则表达式的作用。 用户会通过表单向服务器提交一个phone字符串，使用正则表达式检查这个字符串是否满足手机号的格式要求。 //preg.php $phone = $_GET['phone']; $pregStr = \"/1[3-8][0-9]{9}/i\"; echo '要进行验证的手机号是：'.$phone.''; if(preg_match($pregStr,$phone)){ echo '验证通过'; }else{ echo '验证不通过'; } 当我们向$phone变量传入一个标准手机号格式的字符串时，程序作出相应： 如果传入一个不合理的字符串： 参数验证是服务端的一项重要任务。在进行数据存取的相关开发时，有一条永恒的准则，那就是永远不要相信用户提交的数据。基于这条准则，参数验证就显得尤为重要。在上述问题中，如果用户没有提交手机号，而是提交了一个可以被执行的数据库操作语句，那么就有可能会对数据库造成意料之外的操作，甚至是破坏。一般这种攻击被称为SQL注入。 正则表达式经常用于参数验证或内容搜索，在web编程领域具有不可替代的地位。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c12.html":{"url":"s2/c12.html","title":"Chapter12 类与对象","keywords":"","body":"1. Chapter12 类与对象1.1. 类 Class1.2. 对象 Object1.3. this1.4. 面向过程 or 面向对象1.5. 面向对象编程的特性1.6. 继承 extends1.7. 重载1.8. 访问控制：私有/公共/被保护1.9. 静态 static1.9.1. 单例模式1.10. 抽象 abstract1.11. 构造函数 construct1.11.1. 旧式的构造函数1.12. 析构函数 destruct1.13. 多文件1.14. 命名空间 namespace1. Chapter12 类与对象 这部分是面向对象编程的一些基础知识。实际上，学习面向对象编程理念并不会对你已有的编程技术产生一些短期内的提升，有时反而会扰乱了你的思维。如果你想先编写出可以拿得出手的程序，建议先跳过本章。 1.1. 类 Class 类是在之前的叙述中都没有提到过的一种变量类型，可以理解为类是一种声明或定义。 在面向对象编程（如果你从没听过这个词，先向下看）中，一类具有相同特征的实体被抽象为类。举个例子，天下所有的人都是实际存在的，他们都具有生命，具有人类的特征，可以做其他人类该做的事情（普遍意义上来讲）。这样，他们就可以被抽象为一个类\b，类名叫做“人”。 一个类包含属性与方法。属性可以用来描述类的一些特征，方法则是该类可以进行的相关操作。 例如一个“人”类可以声明为： (伪代码) class 人{ 身高; 体重; 长相; 肤色; 国籍; //and so on... 吃饭(){ } 睡觉(){ } 复读(){ } } 在PHP中，声明一个类的标准形式是： class className{ $param1; $param2 = 'param2DefaultValue'; function func(){ //do something } } 1.2. 对象 Object 将一个类进行实例化，就\b定义了一个具有该类特征的实体，这个实体被称为对象。 在PHP中，实例化一个类的标准形式是： $obj = new className(); 一个类可以被实例化成多个实体，多个实体彼此互相独立，在没有人为干扰的情况下互不影响。 在需要使用对象下的属性或者方法时，需要用到成员运算符->。例如如果需要使用obj对象下的param1属性，则使用$obj->param1来表示。如果要调用obj对象下的func方法，则用$obj->func()来表示。 下面的例程展示了类和对象的基本运作原理。 class human{ public $name; public $skinColor; public $language; public function introduce(){ echo 'My name is '.$this->name.',my skin color is '.$this->skinColor.',my language is '.$this->language.\"\\n\\n\"; } } $xiaoming = new human(); $xiaoming->name = 'xiaoming'; $xiaoming->skinColor = 'yellow'; $xiaoming->language = 'Chinese'; $bob = new human(); $bob->name = 'bob'; $bob->skinColor = 'black'; $bob->language = 'English'; $xiaoming->introduce(); $bob->introduce(); 这段代码中，我们先定义了一个“人”类。每个“人”都有姓名、肤色、语言三种属性，并且可以进行自我介绍。 当“人”进行自我介绍的时候，他会告诉你他的名字、肤色、语言。 接下来我们创建了两个“人”，分别是xiaoming和bob，并且为他们赋予了不同的特征。 然后让两位分别做自我介绍，可以看到两者的特征各不相同。 1.3. this this关键字用在类的描述中，表示当前对象，以便此类在日后被实例化成对象之后不要让他忘记自己。 在上面的例子中，this的作用是不管human类被实例化成了xiaoming还是bob，在自我介绍的时候都要报上他自己的特征。 1.4. 面向过程 or 面向对象 在本章之前的所有内容都属于面向过程编程。面向过程编程只需要将想要做的事情依次使用编程语言描述给计算机，计算机读取程序依次执行。面向过程编程的性能比面向对象高，但不易复用且不不宜维护。程序量大了之后的维护工作简直是灾难。 面向对象是另一种思考问题的方式。其实如果不谈论程序，世间万物都可以用“类-对象”的思想来概括。面向对象编程易于维护，它将复杂的系统分为不同的模块，并且让不同模块间尽可能小地互相干扰，这样可以使系统更加灵活。相比于这么多优点，面向对象编程的缺点则是性能低，在性能方面的开销较大。 面向对象和面向过程两种方式各有优缺点，开发者需要在面对问题时合理选择需要使用的思维方式，来取得性能和功能两方向上的平衡。 1.5. 面向对象编程的特性 面向对象编程有三大特性，即封装、继承、多态。 这三大特性将在后面的内容中逐渐介绍给你。 在面向对象编程中，类中的变量被称为“属性”，类中的函数被称为“方法”。 1.6. 继承 extends 一个类可以继承自另外一个类，前者叫“\b子类”，后者叫“父类。子类默认具有父类所有的属性和方法。在\b类的内容丰富程度上来讲，父类应该是子类的子集。 在子类中如果需要描述父类的相关内容，则需要使用关键字 parent来表示父类。 继承使用关键字extends表示，在类的声明时需要注明继承自哪个类。继承关系在类的声明时这样表示： class childClass extends parentClass{ } 子类继承自父类的方法，可以在子类进行重写。即如果子类和父类有相同名称的方法，子类的方法会覆盖来自父类的方法。 可以编写一段程序来体现继承和重写。 首先我们定义一个“动物”类，这种动物具有名字、身高、体重，并且可以吼叫。它在吼叫的时候会告诉大家它是一个动物，还会喊出自己的名字。 对这个动物的描述是 //extends.php class animal{ private $name; private $weight; private $height; public function __construct($name,$weight,$height){ $this->name = $name; $this->weight = $weight; $this->height = $height; } public function speak(){ echo \"I'm a animal! I'm {$this->name}!\\n\"; } } __construct是构造函数，会在类被实例化的时候调用。如果对这个还不太理解，可以试着先跳过。构造函数的相关内容马上就会讲到。 紧接着我们定义一个“人”类。“人”也是“动物”，也具有名字、身高、体重。这样子“人”就可以继承“动物”。 //extends.php class human extends animal{ public function __construct($name,$weight,$height){ $this->name = $name; $this->weight = $weight; $this->height = $height; } public function speak(){ echo \"I'm a human. I'm {$this->name}. \\n\"; } } 与动物不同的是，“人”的吼叫变为讲话。人在讲话的时候会告诉大家他是一个人类，并且还会讲出他的名字。此时“讲话”这个方法则需要重写。 接下来我们实例化两个类，查看结果。 //extends.php $doge = new animal('doge','10kg','20cm'); $xiaoming = new human('xiaoming','60kg','170cm'); $doge -> speak(); $xiaoming -> speak(); 运行结果是 1.7. 重载 在面向对象编程中，重载也是一个重要的特性。在同一个类中定义多个名字相同的方法，它们的返回值或者是参数个数不同，就可以实现不同的功能。这种特性是面向对象编程“多态”的一种体现。 但是重载特性在PHP中不支持，PHP不允许一个类中定义两个同名方法。 //overloading.php class animal{ private $name; private $weight; private $height; public function __construct($name,$weight,$height){ $this->name = $name; $this->weight = $weight; $this->height = $height; } public function speak(){ echo \"I'm a animal! I'm {$this->name}!\\n\"; } public function speak($content,$loud){ echo \"I can speak what I want,\".$content; for($i = 0;$i speak(); $specialAnimal -> speak(); 你只需要知道存在重载这种特性即可，PHP中往往使用魔术方法的方式来实现。具体的实现方法你可以查阅网上的资料。 1.8. 访问控制：私有/公共/被保护 在定义类的属性时，可以对属性值进行更多的描述。 当属性为私有private时，该属性只能在类中被访问； 当属性为公共public时，该属性可以在类定义之外的其他时刻被访问； 当属性为被保护protected时，该属性可以在该类及其子类中被访问。 为了验证这三种修饰词，我们要先准备两个具有继承关系的类。 //prpupr.php class Parents{ private $pri = 'This is a private value'; protected $pro = 'This is a protected value'; public $pub = 'This is a public value'; public function output(){ var_dump($this->pri); var_dump($this->pro); var_dump($this->pub); } } class Child extends Parents{ public function output(){ var_dump($this->pri); var_dump($this->pro); var_dump($this->pub); } } 然后我们要实例化一个类，查看结果。 $parent = new Parents(); $parent->output(); var_dump($parent->pub); var_dump($parent->pri); var_dump($parent->pro); 运行结果是 可以看到，如果在外部直接调用output，让output里面的this去访问类内部的属性，就都可以访问到。如果在类外边，通过对象名去访问类内部的私有方法，则会报错。 接下来实例化一个子类。 $child = new Child(); $child->output(); 运行结果是 可以看到protected和public属性都可以在子类中访问到，但是private属性访问不到。 1.9. 静态 static 可以使用static关键字来定义类中的属性或方法为静态方法或属性，这些方法和属性则会直接属于一个类，并且与对象无关。它们会在整个程序周期中一直存在，并且它们使用类名直接被调用。 由于静态方法可以不用实例化类而直接调用，所以静态方法中不能出现$this。 静态属性和静态方法的调用方式是 Classname::$value; Classname::func(); 在类中要提到其他当前类中的静态属性或方法，则要使用self关键字。 self::$value; self::func(); 下面一段程序则展示了静态属性属于一个类，与某个具体的对象无关。 class Class1{ static public $value = 1; public function add(){ self::$value++; } } $c1 = new Class1(); $c2 = new Class1(); var_dump(Class1::$value); $c1 -> add(); var_dump(Class1::$value); $c2 -> add(); var_dump(Class1::$value); 运行结果是 如果尝试使用对象的方法调用静态属性 var_dump($c2->value); 则会输出null。 因为$c2这个对象中没有$value这个属性，这个属性属于Class1这个类，并不属于任何对象。 1.9.1. 单例模式 PHP有一种经典的设计模式——单例模式，就很巧妙地应用了静态属性和静态方法。 //singleInstance.php class SingleInstance{ private static $inst = false; private function __construct(){ } public static function getInstance(){ if(self::$inst){ return self::$inst; }else{ self::$inst = new self(); return self::$inst; } } } 单例模式的设计理念是，一个类只能被实例化成一个对象，再次实例化则只会得到已经存在的实例。 为了达到这个目的，则需要避免这个类的直接实例化，所以将构造方法设置为private，这样做可以避免类被new关键字直接实例化。 想要获取这个类的实例，只能通过预留的getInstance方法来实现。getInstance会将新创建的实例存到静态属性$inst中，检查到已存在实例，则取到之前创建的实例返回。 在整个过程中，$inst是静态属性，无论这个类被实例化了多少次，这个变量都不会因此而属于哪一个对象。 我们为这个类增加一个用来测试的属性和方法。 //singleInstance.php class SingleInstance{ public $testValue = 1; public function inc(){ echo \"Call inc!\\n\"; $this->testValue ++; } } 由于$testValue是非静态的属性，那么如果实例化了类，它会属于自己的对象。接下来我们要创建两个实例，体验一下单例模式的魅力。 //singleInstance.php $obj1 = SingleInstance::getInstance(); $obj2 = SingleInstance::getInstance(); var_dump($obj1->testValue,$obj2->testValue); $obj1->inc(); var_dump($obj1->testValue,$obj2->testValue); $obj2->inc(); var_dump($obj1->testValue,$obj2->testValue); 运行程序 可以看到，当分别调用了$obj1和$obj2的inc()方法后，两个对象中的$testValue属性值相同。这就说明两次inc()操作的$testValue是同一个值。 实际上由于该类属于单例模式，$obj1和$obj2是同一个对象。 这样就可以测试二者是不是同一个对象了： if($obj1 === $obj2){ echo \"same!\\n\"; } 运行一下 单例模式的优点是节约资源，在面向对象设计模式中是应用得特别多的一种设计模式。在设计数据库类的时候使用单例模式，可以避免同一个数据库在一个程序中被多次连接，这样可以节约很大的服务器资源开销。 1.10. 抽象 abstract 抽象可以用来描述类或方法。 抽象方法只允许描述定义和调用方式，在圆括号()之后直接以分号;结束，不允许有具体实现。抽象方法的具体实现交由它的子类来完成。 包含有抽象方法的类就要被定义为抽象类。包含抽象方法的抽象类这样表示： //abstract.php abstract class AClass{ abstract function aFunc(); } 被定义好的抽象方法，在子类中必须被实现。如果继承了父类后没有实现父类定义好的抽象方法，则会出现错误。 //abstract.php class Class1 extends AClass{ } 所以在子类中一定要实现父类定义的抽象方法。 //abstract.php class Class1 extends AClass{ function aFunc(){ echo \"aFunc here!\\n\\n\"; } } 实例化子类，调用已经实现的方法。 //abstract.php $obj1 = new Class1(); $obj1->aFunc(); 需要特别提到的是，抽象类不允许被实例化。 //abstract.php $obj2 = new AClass(); 如果要实例化抽象类，则会报错。 1.11. 构造函数 construct 构造函数是在类中定义好的，创建对象时调用的方法。它只允许被叫作__construct，并且默认是public的。 在创建一个实例时，我们通常会使用 new Classname(); 来实例化一个对象。实际上是调用了Classname这个类中的构造函数。 如果一个类中的构造函数不是private的，那么它的子类会继承到父类的构造函数。但在子类的构造函数中不会自动调用父类的构造函数。如果需要，则需要在子类的构造函数中使用 parent::__construct(); 来显式调用父类的构造函数。 在讲解继承的时候，我们使用到了构造函数，并且提到 __construct是构造函数，会在类被实例化的时候调用。如果对这个还不太理解，可以试着先跳过。构造函数的相关内容马上就会讲到。 构造函数经常用来做一些初始化的功能。例如在讲解继承的时候，我们使用构造函数对类的属性进行初始化。 //extends.php class animal{ private $name; private $weight; private $height; public function __construct($name,$weight,$height){ $this->name = $name; $this->weight = $weight; $this->height = $height; } public function speak(){ echo \"I'm a animal! I'm {$this->name}!\\n\"; } } 当创建这个类的实例的时候，类名括号里的参数就会被传入构造函数的参数列表中。 new animal('name','weight','height'); 实际上相当于（但不能这样写） animal::__construct('name','weight','height'); 1.11.1. 旧式的构造函数 在PHP5之前，构造函数被规定为，在类中与类名相同的方法。即 class animal{ public function animal($name,$weight,$height){ $this->name = $name; $this->weight = $weight; $this->height = $height; } } PHP5为了做到向下兼容，在一个类实例化的时候如果找不到名字为__construct的方法，那么PHP会尝试寻找一个与类名同名的方法来作为构造函数。 这样的话，如果类中有一个名为__construct的方法却被用于其他用途，则会出现兼容性问题。 自PHP5.3.3起，在命名空间中，与类名同名的方法不再作为构造函数。但是一些其他的面向对象编程语言还坚持着这种传统。 1.12. 析构函数 destruct 在PHP5中引入了析构函数。与构造函数相对地，析构函数会在某个对象被彻底销毁（所有引用都被销毁、显式销毁）之前调用。 如果有继承关系，父类的析构函数不会因为子类创建的对象被销毁而隐式调用。如果需要调用父类的析构函数，则需要使用 parent::__destruct(); 在子类的析构函数中来显式调用。 有趣的是，析构函数甚至会在调用exit()尝试终止脚本时调用。如果在析构函数中调用exit()，则会终止其余的关闭行为。 如果尝试在析构函数中抛出异常，则会出现致命错误。异常相关的内容将在后面进行讲解。 1.13. 多文件 通常在习惯上，大家都是每个文件存放一个单独的类，一个单独的文件只负责一个单独的类的声明，执行则放在另外的文件中。如果想要让多个文件的类之间可以产生互动，或者是在一个文件中用到其他文件中声明的类，只需要使用文件包含函数将众多文件联结起来就可以了。 1.14. 命名空间 namespace 脱离\b具体的编程语言，命名空间是一种封装事物的方法。在日常生活中也有很多应用体现了命名空间的思想。例如计算机文件系统中的文件夹概念。在同一个目录下不允许有重名文件，但在两个目录中就可以存在相同名字的文件。 在PHP中，命名空间的出现解决了在前后开发中出现重复类名因而发生冲突的问题。一个命名空间下的类不允许重名，但即使文件被连接了起来，只要两个类不在同一个命名空间中，就允许存在。 命名空间使用namespace来定义。通常一个文件只包含一个命名空间，但PHP允许单个文件出现多个命名空间，这种特殊的情况在本文档中不会提及。 定义一个命名空间的一般形式是 namespace namespace1; 如果需要使用namespace语句，那么它只能出现在程序的第一行。 命名空间可以理解为是一种虚拟的路径，这个路径是你程序设计的结构。路径使用反斜线\\来表示层次。例如也可以用 namespace Home\\Controller; 来定义一个更深的命名空间。 当需要引用一个命名空间，需要使用use关键字将其引入。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c13.html":{"url":"s2/c13.html","title":"Chapter13 异常处理","keywords":"","body":"1. Chapter13 异常处理1.1. 错误1.2. 异常1.3. 捕获-抛出异常1.4. 自定义异常1. Chapter13 异常处理 1.1. 错误 错误在程序中随处可见，而错误本身也不是不好的东西。一个优秀的程序，应该能处理各种错误情况，将错误处理也纳入自己的程序范围内。 下面我们尝试去人为触发一个错误。 //giveMeAnError.php $file = fopen('notExist.txt','rw'); fopen函数会尝试打开一个文件，当这个文件不存在的时候则会报错。为了触发错误，我们并没有准备这样一个文件。这样，运行程序则会出现 这样的错误信息。 为什么有的时候我们需要针对错误信息做特别的处理呢？事实上，如果上面的代码是某个程序中间的一行，而这个程序运行在浏览器上，是一个网站中间的一部分。这时如果出现了这样的错误，会导致网页全部停止运行，并显示错误信息（如果你配置了显示错误信息的话）。 在运营网站的角度来讲，我们并不期望这样。如果这个文件找不到，我们可以让系统出现一个提示，绕过这个错误，让网站继续运行下去。如果对外显示了错误信息，还会将文件的路径暴露出来，这对服务器来说是不安全的。 如果是上面的文件读取，最简单的处理是这样做。 //giveMeAnError.php $filename = 'notExist.txt'; if(file_exists($filename)){ $file = fopen('','rw'); }else{ die('读取文件失败！'); } 如果希望网站的运行不会受到错误的影响，不妨尝试这个样子。 echo 'alert(\"读取文件失败！\")'; 这样会使用JavaScript的方式弹出一个提示，并且不影响程序其他部分的运行。 上面的几种方式都是最简单粗暴处理错误的方式。 1.2. 异常 1.3. 捕获-抛出异常 1.4. 自定义异常 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c14.html":{"url":"s2/c14.html","title":"Chatper14 日期与时间","keywords":"","body":"1. Chatper14 日期与时间1.1. UNIX时间戳1.2. 一些常见的数字1.3. 在PHP中获取时间戳1.4. 时间戳转换标准日期1.4.1. “日”相关1.4.2. “星期”相关1.4.3. “月”相关1.4.4. “年”相关1.4.5. 时间相关1.4.6. 时区相关1.5. 时区1. Chatper14 日期与时间 在web编程中，日期与时间属于一种特殊的值，\b经常出现在各种不同的场景。在正式开始\b之前，你可能需要了解一下，在计算机的思想中，它是怎样去理解我们意识中的“时间”的。 1.1. UNIX时间戳 在程序的世界中，造物主们将1970年1月1日（UTC/GMT的午夜）的第1秒规定为UNIX时间戳的第0\b秒。由于北京是+8时区，所以在中国，UNIX时间戳的起点是1970年1月1日早上的8时0分0秒。 如果在一个可以查看时间戳的网站查询UNIX时间戳为0秒时候的时间日期，则可以看到 从这个起点开始，每过1秒，UNIX时间戳就增加1。UNIX时间戳统一了世界各地的计时单位，也让开发者在不同的开发平台上能去遵守同一个时间的表达规则。 UNIX时间戳的单位通常是秒，在PHP中默认也将获取到以秒为单位的UNIX时间戳。在其他的一些语言中会默认获取到毫秒。 对于时间，还有一个事情要做解释。 通常来说，PHP接收的\b时间戳范围应该是1901年12月13日（-2146648446）20:45:54到2038年1月19日03:14:07（2147454847），因为此范围符合32位有符号整数的最小值和最大值。 1.2. 一些常见的数字 明白了UNIX时间戳的运行规则，我们接下来会列举一些在开发中常见的数字，这样可能会利于你更容易地了解UNIX时间戳。 时间 秒 1分钟 60 1小时 3600 1天 86400 1周 604800 1月(30天) 2592000 1年 (365天) 31536000 如果是毫秒的时间戳，则需要在上述数字基础上乘以1000。 1.3. 在PHP中获取时间戳 在PHP中获取时间戳的内置函数是time(),它会返回当前的UNIX时间戳。 这个时间戳是以秒为单位的，如果下文中没有特别提及，则都默认为以秒为单位的时间戳。 例如调用这个函数 //time.php var_dump(time()); 运行结果是 1.4. 时间戳转换标准日期 时间戳虽然可以代表一个唯一并永不重复的时间点，但时间戳却有一个致命的弱点，那就是它不易阅读。除非借助程序或相关工具，否则时间戳是不能当成日期来显示给用户的。 在PHP中，系统提供了处理时间戳的函数。使用date()函数可以将时间戳转为表示日期的字符串。date的函数原型是： string date (string $format[,int $timestamp]) $format接收一个负责格式化的字符串，date会按照$format给定的格式来转换时间戳$timestamp。$timestamp是可选参数，默认值是time()。 我们尝试调用这个函数，来转换当前的时间戳。 //now.php $now = time(); $nowStr = date('Y-m-d H:i:s'); var_dump($now,$nowStr); 这段程序的运行结果是 但是这个日期和我的系统时间 并不相同。这其中的原因，我们稍后再讲解。现在当务之急是要讲解一下，格式化字符串$format都接收什么样的值。 上面的例子中，Y、m、d、H、i、s都是预定好的字符，它们在格式化字符串中有各自固定的意义。开发者可以按照自己的意愿任意排列这些预定好的字符，来实现自己想要的日期格式。 预定好的字符和它们各自的意义如下表所示。 1.4.1. “日”相关 字符 说明 举例 d 表示“日”的2位数字 01~31 j 表示“日”的数字，不会补0 1~31 S 表示每个月天数后面的2位英文字符，可以和j一起用 st、nd、rd、th D 一周的第几天，3个字母 Mon~Sun l 一周的第几天，完整的英文单词 Sunday到Saturday N 用数字表示的周几这个是ISO-8601规定的 1（周一）~7（周日） w 一周当中的第几天 0（周一）~6（周日） z 一年当中的第几天 0~365 1.4.2. “星期”相关 字符 说明 举例 W 一年当中的第几周，每周从周一开始这个是ISO-8601规定的需要PHP>4.0.1 42 1.4.3. “月”相关 字符 说明 举例 F 完整的表示月份的单词 January~December M 三个字母缩写表示的月份 Jan~Dec m 2位数字表示的月份 01~12 n 数字表示的月份，不会补0 1~12 t 指定的月份有几天 28~31 1.4.4. “年”相关 字符 说明 举例 L 是否是闰年 是为1，否为0 Y 4位数字表示的年份 2008 y 2位数字表示的年份 08 1.4.5. 时间相关 字符 说明 举例 a 小写的上午或下午 am或pm A 大写的a AM或PM g 12小时格式的时间数，不会补0 1~12 G 24小时格式的时间数，不会补0 0~23 h 12小时格式的2位时间数 01~12 H 24小时格式的2位时间数 00~23 i 2位分钟数 00~59 s 2位秒数 00~59 u 毫秒PHP>5.2.2 654321 1.4.6. 时区相关 字符 说明 举例 e 时区标识PHP>5.1.0 UTC、GMT、Atlantic/Azores I 是否为夏令时 是为1，否为0 T 本机所在时区 EST、MDT在windows下会变成完整的单词形式 c ISO-8601格式的日期（PHP>5） 2004-02-12T15:19:21+00:00 r RFC-822 格式的日期 Thu, 21 Dec 2000 16:01:07 +0200 \b所有在$format中不是规定字符组成的字符串，在date()的返回值中将按原样显示。 如果要将字符串转换回时间戳，则需要使用strtotime()函数。也就是 $time === strtotime(date('Y-m-d H:i:s',$time)); 是成立的。 1.5. 时区 接下来我们要解决上面提到的，格式化出当前时间与系统表示的时间并不相同。这是时区的问题。看过了格式化字符串之后，我们改造上面的代码： //now.php $now = time(); #changed $nowStr = date('T,Y-m-d H:i:s'); var_dump($now,$nowStr); 在新的版本中，我们在格式化字符串中使用T来查看当前时区，重新运行程序 我们发现当前系统的时区是UTC。UTC的意义是协调世界时，又称世界统一时间、世界标准时间、国际协调时间。而现在我所在的位置，是在中国所在的时区Asia/Shanghai。查阅资料可得知，Asia/Shanghai是UTC+8时区。所以，当前系统时间应该比程序所获取到的时间多8小时。这样解释就合理了。 那么如果我们的程序运行在中国，但展示给用户的却是UTC的时间，这样用户肯定不买账。所以我们需要在程序开始的时候指定时区。在PHP中使用date_default_timezone_set()函数指定时区。这个函数接收一个表示时区的字符串，例如上面提到的Asia/Shanghai。这个字符串接收的有效的值可以查阅PHP手册。 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c15.html":{"url":"s2/c15.html","title":"Chapter15 web编程基础","keywords":"","body":"1. Chapter15 web编程基础1. Chapter15 web编程基础 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "},"s2/c16.html":{"url":"s2/c16.html","title":"Chapter 框架与架构简介","keywords":"","body":"1. Chapter 框架与架构简介1. Chapter 框架与架构简介 这本书是xt写的/上次修改： 2019-04-17 14:57:44 "}}